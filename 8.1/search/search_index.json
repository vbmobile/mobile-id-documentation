{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Getting started","text":""},{"location":"index.html#prerequisites","title":"Prerequisites","text":"AndroidiOS <p>To integrate the Mobile ID SDK for Android, the following prerequisites must be met:</p> <ul> <li>Install or update Android Studio to latest version;</li> <li>Target API level 24 (Marshmallow) or later;</li> </ul> <p>To integrate the Mobile ID SDK for iOS, the following prerequisites must be met: </p> <ul> <li>Install or update Xcode to latest version;</li> <li>Target iOS 13 or later. </li> </ul> <p>You must also send an ID (Bundle ID or Application ID) to vision-box so that we can associate the API key with the application, this way your API key is protected with only authorized applications.</p>"},{"location":"index.html#enrolment-sdk-setup","title":"Enrolment SDK setup","text":"AndroidiOS <p>To add the Enrolment SDK to your app, perform the following steps:</p> <ol> <li>Add these new repositories in your app top level gradle file: <pre><code>maven { url \"https://vbmobileidstorage.blob.core.windows.net/android/\" }\nmaven { url \"https://maven.regulaforensics.com/RegulaDocumentReader\" }\n</code></pre></li> <li>Declare Mobile ID SDK and document reader provider as a dependency in your app level gradle file: <pre><code>implementation(\"com.visionbox.mobileid.sdk:mid-sdk-enrolment:&lt;8.1.1&gt;@aar\") { transitive = true }\nimplementation(\"com.visionbox.mobileid.sdk:vb-ocrmrzrfid-regula:&lt;1.0.4&gt;\")\n</code></pre> Or declare Mobile ID SDK and document reader provider following the BOM pattern instead: <pre><code>implementation(platform('com.visionbox.mobileid.sdk:mobileid-bom:8.1.1'))\nimplementation(\"com.visionbox.mobileid.sdk:mid-sdk-enrolment\")\nimplementation(\"com.visionbox.mobileid.sdk:vb-ocrmrzrfid-regula\")\n</code></pre></li> <li>Add these rules to proguard if you have problems running the application with minify enabled: <pre><code>-keepclassmembers enum * { *; }\n-dontwarn org.joda.convert.FromString\n-dontwarn org.joda.convert.ToString\n\n# Keep Data classes so we can use Moshi to parse the internal BuildSubjectParameters from firebase to spoof document, bcbp and face capture data\n-keep class com.visionbox.mobileid.sdk.enrolment.data.** { *; }\n</code></pre></li> <li>Sync gradle.</li> </ol> <p>To add the Enrolment SDK to your app, perform the following steps:</p> <p>CocoaPods</p> <p>To always use the latest release, add the following to your Podfile:</p> <ol> <li>Add the following to your Podfile, with the latest version: <pre><code>pod 'MobileIdSDKiOS', '8.1.0'\npod 'VBOcrMrzRfidRegula', '1.1.0'\n</code></pre></li> <li>Add Mobile ID\u2019s cocoapods repo as a source in your podfile: <pre><code>source \u2018https://cdn.cocoapods.org/\n</code></pre></li> <li>Run in Terminal the command below to install pods in your project: <pre><code>pod install\n</code></pre></li> </ol> <p>NOTE: Due the necessity of the SDK to be built for distribution, a post installscript might be needed in your Podfile: (https://github.com/CocoaPods/CocoaPods/issues/9232). Example: <pre><code>post_install do |installer|\n    installer.pods_project.build_configurations.each do |config|\n        config.build_settings['BUILD_LIBRARY_FOR_DISTRIBUTION'] = 'YES'\n        config.build_settings[\"EXCLUDED_ARCHS[sdk=iphonesimulator*]\"] = \"arm64\"\n    end\nend\n</code></pre></p> <p>SPM</p> <ol> <li>In Xcode, naviate to File &gt; Add Package Dependencies.</li> <li> <p>In the prompt that appears, enter the package URL:</p> <p>For MobileIdSDKiOS <pre><code>https://github.com/vbmobile/MobileIdSDKiOS\n</code></pre> For VBOcrMrzRfidRegula <pre><code>https://github.com/vbmobile/VBOcrMrzRfidRegula\n</code></pre></p> </li> <li> <p>Select the version you want to use. For new projects, we recommend using the newest version of SeamlessMobile SDK.</p> </li> <li>Select the project you want to add the package.</li> <li>Click Add Package.</li> </ol> <p>Once you're finished, Xcode will begin downloading and resolving dependencies.</p> <p>Migration from CocoaPods to SPM</p> <p>If migrating from a CocoaPods-based project, run <code>pod deintegrate</code> to remove CocoaPods from your Xcode project. The CocoaPods-generated .xcworkspace file can safely be deleted afterward. </p> <p>If you're adding SeamlessMobile SDK Swift Packages to a project for the first time, ignore this notice.</p>"},{"location":"index.html#how-to-initialize-the-sdk","title":"How to initialize the SDK","text":"<p>The Enrolment provides access to all the SDK features in a simple way. Since version 8, this was changed to a Singleton to make it accessible anywhere in your application.</p> <p>You can also specify the configurations that will be needed depending on the SDK functionalities you intend to use on your app.</p> <p>You just need to call the initialize method and then you can call the getInstance method to access the features individually.</p> <p>The initialize method does asynchronous work to prepare everything you might need for each feature, so you will receive a callback function when it's ready to use.</p> <p>The SDK also allows client apps to use their own custom views for its functionalities. These custom views must be defined when creating the Enrolment instance. For more information on custom views, please check the advanced configurations section.</p> AndroidiOS <p><pre><code>val apiConfig = APIConfig(\n    baseUrl = URL(\"YOUR BASE URL\"),\n    timeout = 30, // timeout in seconds\n    logLevel = MobileAPILogLevel.BASIC,\n    apiKey = \"YOUR KEY\",\n    publicKey = Base64.encodeToString(\"YOUR PUBLIC KEY\", Base64.DEFAULT), // Optional parameter to ensure requests are encrypted\n)\n\nval enrolmentConfig = EnrolmentConfig(apiConfig)\n\nval regulaDocumentRfidProvider = RegulaProvider.getInstance(\n        DocumentReaderConfig(\n            multipageProcessing = true,\n            databaseId = \"DatabaseName\"\n        )\n)\n\nval callback = object : EnrolmentInitializerCallback {\n    override fun onEnrolmentInitialized() {\n        if (isAdded) {\n            binding.state.text = getString(R.string.sdk_state_ready)\n        }\n        Log.d(\"Enrolment\", \"onEnrolmentInitialization: Enrolment initialized successfully!\")\n    }\n\n    override fun onEnrolmentInitializationError(error: FeatureError) {\n        Log.e(\"Enrolment\", \"onEnrolmentInitializationError: ${error.description}\")\n        activity?.runOnUiThread {\n            binding.state.text = getString(R.string.sdk_state_error)\n            val builder = AlertDialog.Builder(requireContext())\n            builder.setTitle(\"Enrolment Initialization Error\")\n            builder.setMessage(error.description)\n            builder.show()\n        }\n    }\n}\n\nEnrolment.initialize(\n    context, \n    enrolmentConfig,\n    documentReaderProvider = regulaDocumentRfidProvider,\n    rfidReaderProvider = regulaDocumentRfidProvider,\n    callback\n)\n</code></pre> The following parameters must always be provided:</p> <ul> <li>Context - Application context;</li> <li>EnrolmentConfig - Enrolment configuration.</li> <li>EnrolmentCustomViews - Will overwrite any default view from the Enrolment SDK</li> <li>Document and RFID reader provider - The preferred provider for document and rfid read operations</li> <li>EnrolmentInitializerCallback - To receive a callback when the enrolment is initialized or when an error occurs during the process.</li> </ul> <pre><code>private let enrolmentConfig = EnrolmentConfig( apiConfig: APIConfig(\n        baseURL: \"YOUR BASE URL\",\n        timeout: 30, // timeout in seconds\n        logLevel: .basic,\n        apiKey: \"YOUR KEY\",\n        publicKey: \"YOUR PUBLIC KEY\" // Optional parameter to ensure requests are encrypted\n))\n\nvar documentReaderConfig = DocumentReaderConfig(multipageProcessing: false, \n                                                databaseID: \"DatabaseName\")\n\n    Enrolment.shared.initWith(enrolmentConfig: enrolmentConfig,\n                              documentScanProvider: RegulaDocumentReaderScan(config: documentReaderConfig),\n                              documentRFIDProvider: RegulaDocumentReaderRFID(),\n                              viewRegister: viewRegister,\n                              completionHandler: { result in\n    switch result {\n    case .success(_):\n        print(\"Success: SeamlessMobile SDK is ready to use\")\n    case .failure(let error):\n        print(\"Failure: error.description\")\n    }\n})\n</code></pre> <p>The following parameters must always be provided:</p> <ul> <li>EnrolmentConfig - Enrolment configuration.</li> <li>CompletionHandler - To receive a callback when the enrolment is initialized or when an error occurs during the process.</li> </ul> <p>The following parameters must be provided if you want read documents:</p> <ul> <li>Document and RFID reader provider - The preferred provider for document and rfid read operations</li> </ul> <p>The following parameters must be provided if you want customize the screens</p> <ul> <li>EnrolmentCustomViews - Will overwrite any default view from the Enrolment SDK</li> </ul> <p>There where some errors created to validate the enrolment configuration:</p> <ul> <li>If the apiKey is not in a valid format, for example it has an extra character, you will receive via callback an InvalidApiKey error(010 - APIKey is invalid)</li> <li>If the baseUrl is not correctly defined, for example it's using HTTP instead of HTTPS, you will receive via callback an InvalidEndpoint error(011 - Endpoint is invalid)</li> <li>If an error occurs during the initialize method, for example internet connection during the fetch configurations, you will receive via callback an InitFailed error(012 - Error while fetching configurations. Please check your internet connection and API URL/API Key.)</li> </ul> <p>If you try to call a feature while the Enrolment is not ready you will receive a NotReady error (013 - Enrolment is not ready yet. Wait for the callback.)</p>"},{"location":"index.html#offline-mode-support","title":"Offline Mode Support","text":"<p>From version 8.1.0 onwards the SDK offers an offline mode, allowing apps without internet connection to still use some of the features.</p> <p>In offline mode we support the following features:</p> <ul> <li>Face Capture (Without liveness)</li> <li>Document Reader</li> <li>Boarding Pass Scan</li> </ul> <p>Face match and subject management are not compatible as they need internet access to properly work.</p> <p>To ensure offline mode compatibility, you will need the following:</p> <ul> <li>An offline license. (Contact your liaison in Vision-Box/Amadeus)</li> <li>Put the Regula Database, license and master list in your app's assets (Optional for document reader feature)</li> <li>Import the bundled version of face detection ml-kit library (Optional for face capture feature Android only)</li> </ul> <p>You can follow this platform specific guide to prepare your application to offline mode support:</p> AndroidiOS <p>Instead of calling Enrolment.initialize, there's a new method in the facade Enrolment.initializeOffline: <pre><code>val license = \"YOUR_LICENSE_CONTENT\"\nEnrolment.initializeOffline(\n    context = context, \n    enrolmentConfig = enrolmentConfig,\n    documentReaderProvider = documentReaderProvider,\n    rfidReaderProvider = documentReaderProvider,\n    enrolmentInitializerCallback = callback,\n    license = license\n)\n</code></pre></p> <p>In your project, create a new folder named \"Regula\" in your app's assets folder:</p> <ul> <li>app/src/main/assets/Regula</li> </ul> <p>Place the Database, Regula License and master list files in the new folder. The names of the files must be the following:</p> <ul> <li>Database   -&gt; \"db.dat\"</li> <li>License    -&gt; \"regula.license\"</li> <li>Masterlist -&gt; \"csca_certificates.ldif\"</li> </ul> <p>In your app's module build.gradle import the Bundled version of the ml-kit face-detection <pre><code>dependencies {\n    // ...\n    // Use this dependency to bundle the model with your app\n    implementation 'com.google.mlkit:face-detection:16.1.7'\n}\n</code></pre></p> <p>Instead of calling <code>Enrolment.shared.initWith</code>, there's a new method in the facade, <code>Enrolment.shared.initOffline</code>:</p> <pre><code>let license = \"YOUR_LICENSE_CONTENT\"\nEnrolment.shared.initOffline(\n    enrolmentConfig: enrolmentConfig,\n    documentScanProvider: documentScanProvider,\n    documentRFIDProvider: documentRFIDProvider,\n    viewRegister: viewRegister,\n    jwtToken: jwtToken,\n    bundle: bundle,\n    completionHandler: completionHandler,\n)\n</code></pre> <p>Place the Database, Regula License and master list files in your project's folder. The names of the files must be the following:</p> <ul> <li>Database   -&gt; \"db.dat\"</li> <li>License    -&gt; \"regula.license\"</li> <li>Masterlist -&gt; \"csca_certificates.ldif\"</li> </ul> <p>Note that these steps are bound to increase your final apk size as it contains files that were previously downloaded in runtime.</p>"},{"location":"index.html#data-security","title":"Data Security","text":"<p>In version 7.1, an hybrid encryption system was implemented to protect sensitive information and to prevent possible attacks.</p> <p></p> <p>The requests that are sent from the mobile platforms (both iOS and Android) now encrypt the headers that contain sensitive information, and the api key is hashed to prevent it from being leaked.</p> <p>The algorithm used to encrypt the headers is RSA-ECB with a secure padding algorithm.  This cypher mechanism uses a public key to encrypt it and a private key that is only known by the Backend so that they are able to decrypt the headers and verify the data.</p> <p>It is possible to pass a public key as a string in the APIConfig, but you need to pass us the matching private key so that it's uploaded into the backoffice, otherwise the default keys will be used.</p> <p>The API key now also validates if the application that is making the request is known by checking it's ID.  This prevents unauthorized access by using leaked API keys. You need to give us the application IDs that should be allowed to use your API key.</p> <p>In matters of user sensitive information (eg: biometric face capture image), the body of every HTTP request is now encrypted by using AES and a secure padding with a dynamically generated IV. This aims to prevent leaked information by the use of proxy's or interceptors.</p> <p>There's also a data integrity validation system that checks if the response information was not tampered with by comparing the body's hashed value with one of the headers.</p> <p></p>"},{"location":"index.html#configurations","title":"Configurations","text":""},{"location":"index.html#enrolmentconfig","title":"EnrolmentConfig","text":"<p>The EnrolmentConfig is where you set the apiConfig and the apiSecurityConfig.</p> AndroidiOS <pre><code>data class EnrolmentConfig(\n    val apiConfig: APIConfig,\n    val apiSecurityConfig: APISecurityConfig = APISecurityConfig(),\n    val language: Locale,\n    val logConfiguration: List&lt;LogConfiguration&gt; = listOf(\n      LogConfiguration(logLevel = LogLevel.INFO, logStrategy = LogStrategy.CONSOLE)\n    ),\n)\n</code></pre> <pre><code>private let enrolmentConfig = EnrolmentConfig(\n    apiConfig: apiConfig ,\n    apiSecurityConfig, apiSecurityConfig\n    language: language\n)\n</code></pre> <ul> <li>apiConfig: Api configuration;</li> <li>apiSecurityConfig: Api security configuration;</li> <li>language: You can set the language in which the SDK will appear. The default is the system   language;</li> <li>logConfiguration: Log Level and Strategy to be used.</li> </ul>"},{"location":"index.html#apiconfig","title":"ApiConfig","text":"<p>You always need to specify the baseUrl for your Mobile ID API instance, as well as your provided API key. You can also configure the timeout value for server responses and the log level.</p> AndroidiOS <pre><code>/**\n * Mobile API server config.\n *\n * @param baseUrl url from Mobile API server.\n * @param timeout timeout of a request.\n * @param logLevel log level for requests (e.g. Body, Headers).\n * @param apiKey key to authorize communication with Mobile API.\n * @param publicKey key to use for ciphering/deciphering for secure communications.\n */\ndata class APIConfig(\n    val baseUrl: URL,\n    val timeout: Long,\n    val logLevel: MobileAPILogLevel = MobileAPILogLevel.NONE,\n    val apiKey: String,\n    val publicKey: String? = null,\n)\n</code></pre> <pre><code>APIConfig(\n    baseURL: \"YOUR BASE URL\",\n    timeout: 30, \n    logLevel:  .basic, \n    apiKey: \"YOUR KEY\" ,\n    publicKey: String? = nil  \n)\n</code></pre> <ul> <li>baseUrl: Url from Mobile API server;</li> <li>timeout: timeout of a request in seconds;</li> <li>logLevel: log level for requests; (Deprecated in favor of Log Configuration)</li> <li>apiKey: key to authorize communication with Mobile API;</li> <li>publicKey: key to use for ciphering/deciphering for secure communications. It needs to be encoded in Base64.</li> </ul> AndroidiOS <pre><code>@Deprecated(message = \"API Log Level is going away. Check out LogConfiguration on EnrolmentConfig\")\nenum class MobileAPILogLevel {\n    /**\n    * no logs.\n    */\n    NONE,\n\n    /**\n    * logs request and response lines.\n    */\n    BASIC\n}\n</code></pre> <pre><code>public enum APILogLevel {\n    /// No logs.\n    case none\n    /// Logs http status code and name of endpoint.\n    case basic\n}\n</code></pre>"},{"location":"index.html#apisecurityconfig","title":"APISecurityConfig","text":"<p>You can use the security config to specify a list of SSL certificates to be trusted when connecting the SDK to a server instance. By providing this configuration, you are activating certificate pinning for every network request made by the SDK.</p> AndroidiOS <pre><code>data class APISecurityConfig(\n    val certificates: List&lt;X509Certificate&gt; = listOf()\n)\n</code></pre> <pre><code>struct APISecurityConfig {\n    /// Certificates to verify against Certificate Pinning\n    let sslCertificates: [SecCertificate]\n    init(sslCertificates: [SecCertificate]) {\n        self.sslCertificates = sslCertificates\n    }\n}\n</code></pre> <ul> <li>certificates: used for certificate pinning</li> </ul>"},{"location":"index.html#log-configuration","title":"Log Configuration","text":"AndroidiOS <p>A log configuration can be added to the EnrolmentConfig to get additional info on some of the operations of the SDK. Console and File strategies are available, these can be useful when integrating this solution and can sometimes provide more information about certain behaviours or errors.</p> <pre><code>class LogConfiguration(\n    val logLevel: LogLevel,\n    val logStrategy: LogStrategy\n)\n\nenum class LogLevel {\n    WARN, ERROR, INFO, VERBOSE, DEBUG\n}\n\nenum class LogStrategy {\n    CONSOLE, FILE\n}\n</code></pre> <p>A log strategy  can be passed to the <code>Enrolment.initWith</code> to get additional info on some of the operations of the SDK. Console and File strategies are available, this can be useful when integrating this solution and can sometimes provide more information about certain behaviours or errors.</p> <pre><code>public enum LogStrategy {\n/// Outputs logs to the console/standard output\n///\n/// - Parameter level: The minimum log level to display. Messages below\n///   this level will be filtered out. For example, if set to `.warn`,\n///   only warning and error messages will be logged.\ncase console(level: LogLevel)\n}\n\npublic enum LogLevel: Int {\n/// No logging will occur\ncase none\n\n/// Logs error messages\n/// Used for critical failures and exceptions\ncase error\n\n/// Logs warning messages\n/// Indicates potential issues that don't prevent execution\ncase warn\n\n/// Logs user or SDK behavior\n/// Suitable for tracking basic user interactions\ncase info\n}\n</code></pre> <p>In order to find the log files in the iPhone's Files application, the INFOPLIST_KEY_UISupportsDocumentBrowser setting in Build Settings should be set to Yes</p> <p></p>"},{"location":"index.html#advanced-configurations","title":"Advanced Configurations","text":"AndroidiOS <p>The other configurations are used by their corresponding facade method:</p> <ul> <li>BoardingPassCustomViews - Specifies the boarding pass custom views.</li> <li>BiometricFaceCaptureCustomViews - Specifies the face capture custom views.</li> <li>DocumentReaderCustomViews - Specifies the document reader custom views.</li> <li>BiometricFaceMatchCustomViews - Specifies the face match custom views.</li> <li>SubjectCustomViews - Specifies the subject custom views.</li> </ul> <p>These custom views are instantiated in the sdk using reflection, so for this reason, pro-guard might obfuscate some constructors. It's important to use pro-guard rules on the custom views that you created to avoid issues on the building process. Check here for more details on how to create rules to keep the class.</p> <p>The following sections show some examples of the mentioned configurations.</p> <pre><code>val enrolmentCustomViews = EnrolmentCustomViews(\n    documentReaderCustomViews = DocumentReaderCustomViews(\n        loadingView = DocumentReaderCustomViewLoading::class.java,\n        rfidInstructionsView = DocumentReaderCustomViewRfidInstructions::class.java,\n        rfidSearchView = DocumentReaderCustomViewRfidSearch::class.java,\n        rfidProcessView = DocumentReaderCustomViewRfidProcess::class.java,\n    ),\n    boardingPassCustomViews = BoardingPassCustomViews(\n        loadingView = BoardingPassCustomViewLoading::class.java\n    ),\n    faceCaptureCustomViews = BiometricFaceCaptureCustomViews(\n        loadingView = BiometricFaceCaptureCustomViewLoading::class.java\n    ),\n    faceMatchCustomViews = BiometricFaceMatchCustomViews(\n        loadingView = BiometricFaceMatchCustomViewLoading::class.java\n    ),\n    subjectCustomViews = SubjectCustomViews(\n        loadingView = SubjectCustomViewLoading::class.java\n    ),\n    formCustomViews = FormCustomViews(\n        loadingView =  FormCustomViewLoading::class.java,\n    )\n)\n\nEnrolment.initialize(\n    context = requireContext().applicationContext,\n    enrolmentConfig = enrolmentConfig,\n    enrolmentCustomViews = enrolmentCustomViews,\n    documentReaderProvider = documentReaderProvider,\n    rfidReaderProvider = documentReaderProvider,\n    enrolmentInitializerCallback = enrolmentInitializerCallback\n)\n</code></pre> <p>You can now apply and implement your own UI solutions for the SDK  with the new feature of custom views for the Mobile ID SDK, giving you even more control with the UI solutions. To enable this feature in your application, you need to create your view and make it conform to the view protocol that you intend to replace in the SDK. Then, you register that view in the new EnrolmentViewRegister class of the SDK  and you build the enrolment instance with that viewRegister  instance. </p> <p>The following code shows an example: <pre><code>let viewRegister = EnrolmentViewRegister()\nviewRegister.registerBiometricFaceCaptureLoadingView(FaceCaptureLoadingView.self)\n\n\nEnrolment.shared.initWith(enrolmentConfig: enrolmentConfig,\n                          documentScanProvider: RegulaDocumentReaderScan(config: documentReaderConfig),\n                          documentRFIDProvider: RegulaDocumentReaderRFID(),\n                          viewRegister: viewRegister,\n                          completionHandler: completionHandler)      \n</code></pre></p>"},{"location":"index.html#localization-support","title":"Localization Support","text":"AndroidiOS <p>If you wish to add localization support to your application or change some of the default values, you will need to add the strings used by Enrolment SDK to each locale strings.xml file.</p> <p>You can redefine each string in the Enrolment SDK with the appropriate translations.</p> <p>This ensures that the Enrolment SDK uses the correct string resources when the user's device is set to a language supported by your application.</p> <p>To do this, you'll need to reference the identifiers found in the values.xml file from the latest release.</p> <p>You can find the values.xml file with all available strings in the project: External Libraries -&gt; Gradle: com.visionbox.mobileid.sdk:mid-sdk-enrolment:x.x.x@aar -&gt; res -&gt; values -&gt; values.xml.</p> <p>If you wish to change the default string values, you will need to access the strings you want to change through EnrolmentProtocol.theme.strings. In the ThemeStrings struct you can find the various types of strings you can modify to your liking by assigning a localizable key or a literal string value.</p> <p>If you wish to add localization support to your application, you need to create a String File(s) for your app and specify which language the file represents.</p> <p>If you pass a language to EnrolmentConfig and do not have a String File that matches said language and the SDK does, the SDK will use its file, but if we do not have a String File of said language, the key value of the localizable key raw value will be used in the UI.</p> <p>If no language is passed to EnrolmentConfig, the SDK will select the device's default language and use a String File compatible with said language. The same logic applies in this case. If you do not have a file for the correspondent language, the SDK will select its file, but if it also does not have one, the localizable key raw values will be displayed in the UI. </p>"},{"location":"index.html#rfid-chip-processing","title":"RFID Chip Processing","text":"AndroidiOS <p>In order to use the RFID feature, the user must give the NFC permission in runtime, otherwise it won't work.  We already handle the permission check and added to the manifest the following:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.NFC\" /&gt;\n</code></pre> <p>So when using the RFID feature, the user will be prompted to concede the permission if it hadn't already.</p> <p>Here you can find the necessary changes in order to read the RFID chip present in some documents:</p>"},{"location":"index.html#permissions","title":"Permissions","text":"<p>Add Near Field Communication Tag Reading under the Capabilities tab for the project\u2019s target:  Add the NFCReaderUsageDescription permission to your Info.plist file as its needed to access the NFC hardware: <pre><code>&lt;key&gt;NFCReaderUsageDescription&lt;/key&gt;\n&lt;string&gt;NFC tag to read NDEF messages&lt;/string&gt;\n</code></pre> Declare com.apple.developer.nfc.readersession.iso7816.select-identifiers a list of application identifiers that the app must be able to read according to ISO7816: <pre><code>&lt;key&gt;com.apple.developer.nfc.readersession.iso7816.select-identifiers&lt;/key&gt;\n&lt;array&gt;\n    &lt;string&gt;A0000002471001&lt;/string&gt;\n    &lt;string&gt;E80704007F00070302&lt;/string&gt;\n    &lt;string&gt;A000000167455349474E&lt;/string&gt;\n    &lt;string&gt;A0000002480100&lt;/string&gt;\n    &lt;string&gt;A0000002480200&lt;/string&gt;\n    &lt;string&gt;A0000002480300&lt;/string&gt;\n    &lt;string&gt;A00000045645444C2D3031&lt;/string&gt;\n&lt;/array&gt;\n</code></pre></p>"},{"location":"index.html#camera-permissions","title":"Camera Permissions","text":"<p>In order for the SDK to use the camera, the user must grant permission to do so.</p> AndroidiOS <p>In order to use the camera related features, the user must give the camera permission in runtime, otherwise it won't work.  We already handle the permission check and added to the manifest the following:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n</code></pre> <p>So when using any feature that needs the camera, the user will be prompted to concede the permission if it hadn't already.</p> <p>To configure access alerts, follow the steps bellow.</p> <p>In the app's Info.plist file, include NSCameraUsageDescription. After including NSCameraUsageDescription in your Info.plist file, provide a message that explains the user why your app needs to capture media. </p>"},{"location":"index.html#custom-styles","title":"Custom Styles","text":"AndroidiOS <p>You can apply your app\u2019s own colors and fonts to all the provided SDK layout solutions, which means that the SDK views can adapt to your app\u2019s design.  It brings control and allows the maintenance of consistency in terms of brand communication when using the SDK custom views for data presentation. </p> <p>The fonts we are using in the SDK are named enrolment_sdk_medium and enrolment_sdk_regular. If you use fonts with the same name in your app, they will be used, otherwise the SDK will use its own.  We do not advise to override strings. Our strings\u2019 names in strings.xml end in _sdk_enrolment precisely to prevent any unexpected behaviors.</p> <p>The list of colors used in each screen will be available on their respective documentation for your reference.</p> <p>You can apply your app\u2019s own styles to all the provided SDK  layout solutions, which means that the SDK  views can adapt to your app\u2019s design.  It brings control and allows the maintenance of consistency in terms of brand communication when using the SDK  custom views for data presentation.</p> <p>The following image shows an example of how you could override SDK  values for fonts, colors and strings: <pre><code>Enrolment.shared.theme.fonts.medium = FontDescription(name: \"FontName-Medium\")\nEnrolment.shared.theme.colors.faceCapture.stateError = UIColor(name: .colorPrimary)\nEnrolment.shared.theme.strings.faceCapture.title = \"Face Capture Title\"\n</code></pre></p> <p>Please check the complete list of colors for your reference:</p> Name Value Section common.clear Clear_SdkEnrolment Base common.black Black_SdkEnrolment Base component.dismissButton DismissButton_SdkEnrolment Base component.transparentOverlay TransparentOverlay_SdkEnrolment Base component.animationIndicatorBackground AnimationIndicationBackgroud_SdkEnrolment Base component.animationIndicatorMessage AnimationIndicatorMessage_SdkEnrolment Base datafield.title DataFieldTitle_SdkEnrolment Base datafield.value DataFieldValue_SdkEnrolment Base datafield.error DataFieldError_SdkEnrolment Base button.primaryTitle ButtonPrimaryTitle_SdkEnrolment Button button.primaryBackground ButtonPrimaryBackground_SdkEnrolment Button button.secondaryTitle ButtonSecondaryTitle_SdkEnrolment Button button.secondaryBackground ButtonSecondaryBackground_SdkEnrolment Button button.secondaryBorder ButtonSecondaryBorder_SdkEnrolment Button documentData.background DocumentDataBackground_SdkEnrolment Document read documentData.title DocumentDataTitleSdkEnrolment Document read documentData.subtitle DocumentDataSubtitle_SdkEnrolment Document read documentData.detailBackground DocumentDataDetailBackground_SdkEnrolment Document read rfidData.background RfidDataBackground_SdkEnrolment Document read rfidData.title RfidDataTitle_SdkEnrolment Document read rfidData.subtitle RfidDataSubtitle_SdkEnrolment Document read faceCapture.background FaceCaptureBackground_SdkEnrolment Face capture faceCapture.title FaceCaptureTitle_SdkEnrolment Face capture faceCapture.flash FaceCaptureFlash_SdkEnrolment Face capture faceCapture.stateLabel FaceCaptureStateLabel_SdkEnrolment Face capture faceCapture.stateValid FaceCaptureStateValid_SdkEnrolment Face capture faceCapture.stateError FaceCaptureStateError_SdkEnrolment Face capture faceCapture.stateNeutral FaceCaptureStateNeutral_SdkEnrolment Face capture boardingPassScan.background BoardingPassScanBackground_SdkEnrolment Boarding pass scan boardingPassPreview.background BoardingPassPreviewBackground_SdkEnrolment Boarding pass scan boardingPassPreview.legHeader BoardingPassPreviewLegHeader_SdkEnrolment Boarding pass scan"},{"location":"index.html#dependencies","title":"Dependencies","text":"AndroidiOS <ul> <li> <p>MLKit</p> <ul> <li>com.google.mlkit:barcode-scanning:17.3.0</li> <li>com.google.mlkit:face-detection:17.1.0</li> <li>androidx.camera:camera-camera2:1.4.0</li> <li>androidx.camera:camera-lifecycle:1.4.0</li> <li>androidx.camera:camera-view:1.4.0</li> </ul> </li> <li> <p>Regula</p> <ul> <li>com.regula.documentreader:api:7.6.11270@aar</li> <li>com.regula.documentreader.core:ocrandmrzrfid:7.6.13479@aar</li> </ul> </li> <li> <p>Lottie</p> <ul> <li>com.airbnb.android:lottie:6.6.0</li> </ul> </li> </ul> <ul> <li>'DocumentReader', '~&gt; 7.5.0'</li> <li>'DocumentReaderOCRRFID', '~&gt; 7.5.0'</li> <li>'lottie-ios', '4.4.1'</li> </ul>"},{"location":"index.html#glossary-and-terminology","title":"Glossary and Terminology","text":"<p>The following descriptions include the terminology found within this manual:</p> Name Description API (Application Program Interface) An application program interface is a set of routines, protocols, and tools for building software applications. Basically, an API specifies how software components should interact. APIS (Advance Passenger Information System) An electronic data interchange system intended to enhance border security. An APIS collects and shares limited data on passengers and crew members, such as identification details from the passport and basic flight information. Passengers must provide this data before traveling to or from certain countries. Then the airlines or vessel operators share it with the computer system of the destination state. BCBP (Bar-Coded Boarding Pass) A standard issued by the International Air Transport Association (IATA) that defines the format and content of electronic boarding passes. BCBP defines the two-dimensional (2D) barcode and the symbologies used for paper and mobile boarding passes. Airlines, airports, and other air industry stakeholders use barcode readers to capture the data from the electronic boarding passes to process the security check and boarding of travelers. Certificate Electronic document establishing a digital identity by combining the identity name or identifier with the public key of the identity, a validity period, and an electronic signature by a third party. DK (Data Key) A key used to protect an entity, where in this instance an entity is biographic data related to a TD, a BCBP, biometric data or other entity relating to a natural person. IATA (International Air Transport Association) A trade association representing airlines worldwide. IATA supports many areas of aviation activity and formulates industry policies on critical aviation issues. IATA works with other international bodies, such as ICAO and WCO. LED (Light Emitting Diode) A two-lead semiconductor light source. LEDs provide many advantages when used for environmental lighting, such as smaller volume, longer lifetime, and lower energy requirements. Liveness Indication whether an acquired biometric sample comes from a genuine living passenger or not. The liveness detection is used to detect if a passenger is trying to spoof the system. MRZ (Machine Readable Zone) MRZ Machine Readable ZoneThe area of the travel document containing data in an optical character recognition format that allows the information to be read automatically by a machine, such as a passport reader. NFC (Near Field Communication) NFC Near Field CommunicationA method of wireless data transfer that evolved from Radio-Frequency Identification (RFID) technology. This method detects and enables two electronic devices near establish communication without the need for an internet connection. Devices with an NFC chip (for example, smartphones) can detect a chip from another device and transfer data when both devices are held within 4 cm (2 in.) from each other. QR code (Quick Response Code) A type of 2D barcode used to provide easy access to information through a smartphone. A QR code consists of black modules (square dots) arranged in a square grid on a white background, which can be read by an imaging device (such as a camera or scanner). The required data is extracted from the patterns that are present in both horizontal and vertical components of the image. The QR code system became widespread due to its fast readability and greater storage capacity compared to standard barcodes. It is commonly used in item identification, product tracking, time tracking, and document management. RFID (Radio-Frequency Identification) A technology of wireless communication that uses radio waves to automatically identify and track objects. The objects contain tags that store electronic information. An RFID system enables readers to retrieve data from identification documents, such as smart cards. RFID devices work within a vicinity of between a few centimeters to several meters (up to 20 feet) for high-frequency devices. TD (Travel Document) A passport or ID card in ICAO format authorised for border control. TLS/SSL TLS SSL Transport Layer Security (TLS) and its predecessor, Secure Sockets Layer (SSL), are cryptographic protocols designed to provide communications security over a computer network. User A person that uses the equipment under the supervision of trained staff. Workflow Orchestrated and repeatable pattern of processes, running in the touchpoints, which represents the desired behaviour of the cluster."},{"location":"Features/BiometricMatch/BiometricMatch_HandleErrors.html","title":"Handle Errors","text":"<p>After obtaining the FeatureError, as shown in the Handle Result section of the feature overview, we pass the object to the handleError function that is going to analyze what error type occurred in this feature and act according to it.</p> AndroidiOS <p>Example can be found here: BiometricMatchHandleErrors <pre><code>private fun handleError(error: MatchReportError?) {\n    if (error != null) {\n        val errorType = error.featureError?.errorType ?: ErrorType.UnknownError\n        when (errorType) {\n            ErrorType.InternalError -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", false)\n            }\n            ErrorType.CommunicationError, ErrorType.FaceMatchError -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", true)\n            }\n            ErrorType.UserRepeated -&gt; {\n                retry()\n            }\n            ErrorType.UserCanceled -&gt; {\n                // User canceled the flow\n                finish()\n            }\n            else -&gt; {\n                Toast.makeText(this, \"An unknown error occurred\", Toast.LENGTH_SHORT).show()\n                finish()\n            }\n        }\n    }\n}\n</code></pre> The boolean in the navigateToErrorScreen function is to configure if the retry button should appear or not.</p> <p>Example can be found here: Sample Project</p>"},{"location":"Features/BiometricMatch/BiometricMatch_Index.html","title":"Biometric Matching","text":"<p>This service allows the submission of two different biometric images, to verify that they represent the same person. This is necessary whenever there is the need of checking if the current user is the same person as the physical ID owner in any enrolment process. The candidate image is also submitted to a service that performs a biometric quality check before the matching process.</p>"},{"location":"Features/BiometricMatch/BiometricMatch_Index.html#initiate-match","title":"Initiate Match","text":"<p>You can easily provide your client app with a biometric check using our SDK\u2019s biometric matching functionality, available in the enrolment facade. You need to provide a BiometricMatchParameters object that includes the reference biometrics image (for example, an official document\u2019s photo), against which you want to test your candidate image, also passed as a bitmap in this object. You also can include the template option if you want to get the images templates. None is the default. Below is the BiometricMatchParameters structure:</p> AndroidiOS <pre><code>data class BiometricMatchParameters(\n    val candidate: Bitmap?,\n    val reference: Bitmap?,\n    val templateOption: TemplateOption = TemplateOption.NONE,\n    val candidateHash: String?,\n    val referenceHash: String?\n)\n</code></pre> <pre><code>public struct BiometricMatchParameters {\n    public let candidate: Data\n    public let reference: Data\n    public let includeTemplate: TemplateOptions\n    public let candidateHash: String?\n    public let referenceHash: String?\n\n    public init(candidate: Data,\n            reference: Data,\n            includeTemplate: TemplateOptions = .none,\n            candidateHash: String?,\n            referenceHash: String?) \n}\n</code></pre> <p>TemplateOptions is an enumeration and it contains the following cases.</p> AndroidiOS <pre><code>enum class TemplateOption {\n    NONE,\n    ALL,\n    CANDIDATE,\n    REFERENCE\n}\n</code></pre> <pre><code>public enum TemplateOptions: String {\n    case none = \"None\"\n    case all = \"All\"\n    case reference = \"Reference\"\n    case candidate = \"Candidate\"\n}\n</code></pre> <p>The <code>candidateHash</code> and <code>referenceHash</code> are the hashes provided by either the FaceCaptureReport and/or the DocumentReaderReport needed to verify data integrity.</p> <p>You can expect either a MatchError response or a MatchReport response. </p> <p>To start the biometric matching, you must call the following method:</p> AndroidiOS <pre><code>/**\n * Matches two face photos to check if they're from the same person.\n *\n * Used to match the user face photo against the photo contained in the chip from the personal document.\n *\n * @param activity [Activity] that will launch the face match feature\n * @param params [BiometricMatchParameters] that contains the user photo, the photo from the document.\n * @param onMatchComplete [OnMatchCompletion] Callback to handle Match Success or Error\n */\nfun matchBiometrics(\n    activity: Activity,\n    params: BiometricMatchParameters,\n    onMatchComplete: OnMatchCompletion,\n)\n</code></pre> <pre><code>func matchBiometrics(parameters: BiometricMatchParameters, viewController: UIViewController, completionHandler: @escaping (Result&lt;MatchReport, MatchReportError&gt;) -&gt; Void)\n</code></pre> <p>A successful MatchReport response means that matching analysis was successfully computed in the server-side platform. If the candidate image (for example, a captured photo) scores above the previously given threshold, the matched value will be true. The field matchDuration gives you information on the request\u2019s duration and also the templates, if they were requested.</p>"},{"location":"Features/BiometricMatch/BiometricMatch_Index.html#handle-result","title":"Handle Result","text":"AndroidiOS <p>Here is how you can get the match report and handle the result for the face match: <pre><code>interface OnMatchCompletion {\n    fun onMatchSuccess(matchReport: MatchReport)\n    fun onMatchError(matchReportError: MatchReportError)\n}\n</code></pre></p> <p>The MatchReportError has the following structure:</p> <pre><code>data class MatchReportError(\n    val userCanceled: Boolean,\n    val featureError: FeatureError?\n)\n</code></pre> <p>These method\u2019s completion handler passes a result , where the MatchReport contains the Match information and MatchReportError contains the possible errors that may occur during the process. Below is an example of usage:</p> <pre><code>self.enrolment.matchBiometrics(\n    parameters: parameters,\n    viewController: vco) { [weak self] result in\n    switch result {\n    case .success(let matchReport):\n        if (matchReport.photosMatched) {\n            self?.view?.onMatchSuccess()\n        } else {\n            self?.view?.onMatchFailed()\n        }\n    case .failure(let error):\n        if error.userCanceled {\n            print(\"onUserCancel\")\n        } else {\n            print(error.featureError.publicMessage)\n        }\n    }\n}\n</code></pre> <p>The MatchReportError has the following structure:</p> <pre><code>    public class MatchReportError: Error {\n    public var userCanceled: Bool\n    public var termsAndConditionsAccepted: Bool\n    public var featureError: FeatureError\n}\n</code></pre> <p>In case of success, the MatchReport has the following structure:</p> AndroidiOS <pre><code>data class MatchReport(\n    val matchDuration: String,\n    val photosMatched: Boolean,\n    val score: Double,\n    val algorithm: String?,\n    val referenceTemplate: String?,\n    val candidateTemplate: String?,\n)\n</code></pre> <pre><code>public struct MatchReport: Codable {\n    public let matchDuration: String\n    public let photosMatched: Bool\n    public let score: Double\n    public let algorithm: String?\n    public let referenceTemplate: Data?\n    public let candidateTemplate: Data?\n}\n</code></pre>"},{"location":"Features/BiometricMatch/BiometricMatch_Index.html#custom-views","title":"Custom Views","text":"<p>The SDK provides default UI solutions for the boarding pass feature flow, as  shown in the following images:</p> <p></p> <p>You can also apply your app\u2019s colors and fonts to these layout solutions, to keep your brand\u2019s image consistent. Check Customization tab to learn more about branding of each view.</p> AndroidiOS <p><pre><code>@Parcelize\nclass BiometricFaceMatchCustomViews(\n    val loadingView: Class&lt;out ICustomBiometricFaceMatch.LoadingView&gt;? = null\n) : Parcelable\n</code></pre> You can use your own custom views in the face match functionality. Your view must implement the SDK view interfaces. For example, if you want to add a custom loading view, your view class must implement the ICustomBiometricFaceMatch.LoadingView interface.</p> <pre><code>public class EnrolmentViewRegister {\n    ...\n\n    // MARK: - Biometric Match\n    public func registerBiometricMatchLoadingView(_ viewType: BiometricMatchLoadingViewType)\n    ...\n}\n</code></pre> <p>You can use your own custom views in the face match functionality. Your view must implement the SDK view protocols. For example, if you want to add a custom loading view, your view class must implement the BiometricMatchLoadingViewType interface.</p> <p>In the customization tab you will also find examples to create your own custom views.</p>"},{"location":"Features/BiometricMatch/BiometricMatch_LoadingView.html","title":"Loading View","text":"<p>The only view of the biometric match flow is the loading view, it appears when the feature is initializing. In this step, a service is called so that the biometric match is done on the server side.</p> <p></p> <p>It contains a title(1), a message(2), an image(3) and a background that can be customized. </p>"},{"location":"Features/BiometricMatch/BiometricMatch_LoadingView.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/BiometricMatch/BiometricMatch_LoadingView.html#text-resources","title":"Text resources","text":"AndroidiOS <p>You can add your own texts and localization by overriding the following string resources: <pre><code>&lt;string name=\"biometric_face_match_title_sdk_enrolment\"&gt;We\u2019re checking your information&lt;/string&gt;\n&lt;string name=\"common_loading_message_sdk_enrolment\"&gt;This will only take a moment&lt;/string&gt;\n</code></pre></p> <p>The best way to override strings is by adding your key through the Theme class</p> <pre><code>Theme.shared.strings.faceMatch.loadingTitle.localized()\nTheme.shared.strings.faceMatch.loadingMessage.localized()\n</code></pre>"},{"location":"Features/BiometricMatch/BiometricMatch_LoadingView.html#colors","title":"Colors","text":"AndroidiOS <p>You can change the text colors by overriding the following color resource (It affects all texts): <pre><code>&lt;color name=\"colorFaceCaptureTxtDarkSdkEnrolment\"&gt;#1A1C1E&lt;/color&gt;\n</code></pre></p> <p>You can change the background color by overriding the following color resource: <pre><code>&lt;color name=\"colorOverlayFeedbackBgSdkEnrolment\"&gt;#EAEEF6&lt;/color&gt;\n</code></pre></p> <p>You can change the text colors by overriding the following color in Theme class (It affects all Loading Screens):</p> <pre><code>Theme.shared.colors.checkPermission.title\nTheme.shared.colors.checkPermission.subtitle\n</code></pre> <p>You can change the background color by overriding the following color in Theme class(It affects all Loading Screens):</p> <pre><code>Theme.shared.colors.checkPermission.background\n</code></pre>"},{"location":"Features/BiometricMatch/BiometricMatch_LoadingView.html#styles","title":"Styles","text":"AndroidiOS <p>You can extend the styles we use and override any properties (textColor, textSize, fontFamily, etc...) you want. <pre><code>&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Title.Centered\"&gt;\n&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Subtitle.Centered\"&gt;\n</code></pre> Note: It will affect every component that uses the same style.</p> <p>You can change the font through the theme class (this will affect all text in the app): <pre><code>Theme.shared.fonts.bold\nTheme.shared.fonts.regular\n</code></pre></p>"},{"location":"Features/BiometricMatch/BiometricMatch_LoadingView.html#image","title":"Image","text":"AndroidiOS <p>You can change the loading image by adding a drawable with this name: <pre><code>ic_verification_loading.xml\n</code></pre> The image we are using is 240x240dp.</p> <p>You can change the loading image by overriding the following image name in Theme class <pre><code>Theme.shared.images.faceMatch.matchLoading\n</code></pre></p>"},{"location":"Features/BiometricMatch/BiometricMatch_LoadingView.html#use-your-own-layouts","title":"Use your own layouts","text":"AndroidiOS <p>To use your own loading screen for face match feature, you need to implement the MobileID SDK Interface for that view.</p> <p>In this case: ICustomBiometricFaceMatch.LoadingView <pre><code>interface LoadingView {\n    fun onPreFeatureLoading()\n    fun onServerCommunication()\n    fun onPreparingFeature()\n    fun hideLoading()\n}\n</code></pre> You can use the functions above to change loading screen texts in runtime, or you can opt to ignore those functions.</p> <p>For example create a class BiometricMatchLoadingCustomView, create a layout file and bind it.</p> <pre><code>class BiometricMatchLoadingCustomView (\n    context: Context\n) : LinearLayoutCompat(context), ICustomBiometricFaceMatch.LoadingView {\n    private var binding: ViewBiometricMatchLoadingBinding\n\n    init {\n        binding = ViewBiometricMatchLoadingBinding.inflate(LayoutInflater.from(context), this)\n        orientation = VERTICAL\n        gravity = Gravity.CENTER\n    }\n\n    override fun onPreFeatureLoading() {\n        // Do nothing\n    }\n\n    override fun onServerCommunication() {\n        binding.tvFaceMatchLoadingTitle.text = \"Initializing Biometric Match\"\n        binding.tvFaceMatchLoadingMessage.text = \"Loading, please wait..\"\n    }\n\n    override fun onPreparingFeature() {\n        binding.tvFaceMatchLoadingTitle.text = \"Matching biometrics\"\n        binding.tvFaceMatchLoadingMessage.text = \"Please wait..\"\n    }\n\n    override fun hideLoading() {\n        // Do nothing\n    }\n}\n</code></pre> <p>You need to register a class of type BiometricMatchLoadingViewType through the following function of EnrolmentViewRegister <pre><code>public func registerBiometricMatchLoadingView(_ viewType: BiometricMatchLoadingViewType)\n</code></pre></p> <p>The BiometricMatchLoadingViewType class needs to respect the following protocols:</p> <pre><code>public protocol BiometricMatchLoadingViewInterface : FeatureLoadingViewInterface {\n    func onPreparingFeature()\n}   \n\npublic typealias BiometricMatchLoadingViewType = BiometricMatchLoadingView.Type\npublic typealias BiometricMatchLoadingView = UIView &amp; BiometricMatchLoadingViewInterface\n\npublic protocol FeatureLoadingViewInterface {\n    func onPreFeatureLoading()\n    func onPostFeatureLoading()\n    func hideLoading()\n}\n\npublic typealias FeatureLoadingViewType = FeatureLoadingView.Type\npublic typealias FeatureLoadingView = UIView &amp; FeatureLoadingViewInterface\n</code></pre> <p>Example: <pre><code>class LoadingView: LoadingOverlayView {\n// MARK: - Initialization\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        //add any UI customization you need\n    }\n\n// MARK: - Functions\n\n    func onPreparingFeature() {\n        //add any UI customization you need\n    }\n\n    func onPreFeatureLoading() {\n        //add any UI customization you need\n    }\n\n    func onPostFeatureLoading() {\n        //add any UI customization you need\n    }\n\n    func hideLoading() {\n        //You can stop animations or other activities that consumes resources \n    }\n}\n</code></pre></p>"},{"location":"Features/BoardingPass/BoardingPass_HandleErrors.html","title":"Handle Errors","text":"<p>After obtaining the FeatureError, as shown in the Handle Result section of the feature overview, we pass the object to the handleError function that is going to analyze what error type occurred in this feature and act according to it.</p> AndroidiOS <p>Example can be found here: BoardingPassHandleErrors <pre><code>private fun handleError(error: BoardingPassError?) {\n    if (error != null) {\n        val errorType = error.featureError?.errorType ?: ErrorType.UnknownError\n        when (errorType) {\n            ErrorType.InternalError -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", false)\n            }\n            ErrorType.CommunicationError,\n            ErrorType.BoardingPassInvalidError,\n            ErrorType.PermissionNotGrantedError,\n            ErrorType.ScanError -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", true)\n            }\n            ErrorType.UserRepeated -&gt; {\n                retry()\n            }\n            ErrorType.UserCanceled -&gt; {\n                // User canceled the flow\n                finish()\n            }\n            else -&gt; {\n                Toast.makeText(this, \"An unknown error occurred\", Toast.LENGTH_SHORT).show()\n                finish()\n            }\n        }\n    }\n}\n</code></pre> The boolean in the navigateToErrorScreen function is to configure if the retry button should appear or not.</p> <p>Example can be found here: Sample Project</p>"},{"location":"Features/BoardingPass/BoardingPass_Index.html","title":"Boarding Pass","text":"<p>The boarding pass scan is used to extract encoded information in boarding passes that comply with the BCBP (Bar-Coded Boarding Pass) standard. The SDK is prepared to return the data from boarding passes in the following supported formats: </p> <ul> <li>Barcode PDF417;</li> <li>Aztec;</li> <li>QR code;</li> <li>DataMatrix.</li> </ul> <p>Additionally, you can submit the boarding pass data to a back-end server platform when creating a subject.</p>"},{"location":"Features/BoardingPass/BoardingPass_Index.html#initiate-scan","title":"Initiate Scan","text":"<p>Another functionality available in the enrolment facade is the bar-coded boarding pass scanning. This is helpful whenever your app needs to extract all encoded information in a printed or digital boarding pass if it was generated according to the international BCBP standard. </p> <p>The mobile device will be able to scan boarding passes using the back camera. The SDK supports all the available formats in the IATA Bar-Coded Boarding Pass standard: PDF417, Aztec, QR code and DataMatrix. To start the barcode scanner, you must call the following method:</p> AndroidiOS <pre><code>/**\n * Scans a Bar Coded Boarding Pass (BCBP).\n *\n * @param activity [Activity] that will launch the face capture feature\n * @param params [BoardingPassScanParameters] required to start the boarding pass scan feature.\n * @param onScanBoardingPassCompletion [OnScanBoardingPassCompletion] callback to handle Success and Error scenarios\n */\nfun scanBoardingPass(\n    activity: Activity,\n    params: BoardingPassScanParameters,\n    onScanBoardingPassCompletion: OnScanBoardingPassCompletion,\n)\n</code></pre> <pre><code>func scanBoardingPass(parameters: ScanBoardingPassParameters, viewController: UIViewController, completionHandler: @escaping (Result&lt;BoardingPassFull, BoardingPassError&gt;) -&gt; Void)\n</code></pre> <p>The BoardingPassScanParameters has the following structure:</p> AndroidiOS <pre><code>@Parcelize\ndata class BoardingPassScanParameters(\n    val validate: Boolean\n) : Parcelable\n</code></pre> <pre><code>public struct ScanBoardingPassParameters {\n    public let validateBoardingPass: Bool\n\n    public init(validateBoardingPass: Bool)\n}\n</code></pre> <p>The validate flag should be set to true if you want the SDK to validate the boarding pass data. </p> <p>If you want to use your own boarding pass scanner, you can also provide the raw result of the scan and pass it to the facade\u2019s parser method. It will return the BoardingPass object. The raw result must be passed to the BoardingPassData, which has to be included in the BoardingPassParserParameters.</p> <p>From version 7 onwards there is a new way to parse a boarding pass, by giving us an image URI and if the boarding pass is detected in it, it will be parsed and you will receive a BoardingPass object without requiring to provide us the format.</p> AndroidiOS <pre><code>/**\n * Parses a Bar Coded Boarding Pass (BCBP).\n *\n * @param activity [Activity] that will launch the face capture feature\n * @param params [BoardingPassStringParserParameters] required to start the boarding pass parser feature.\n * @param onParseDocumentCompletion [OnScanBoardingPassCompletion] callback to handle Success and Error scenarios\n */\nfun parseBoardingPass(\n    activity: Activity,\n    params: BoardingPassStringParserParameters,\n    onParseDocumentCompletion: OnScanBoardingPassCompletion,\n)\n\n/**\n * Parses a Bar Coded Boarding Pass (BCBP).\n *\n * @param activity [Activity] that will launch the face capture feature\n * @param params [BoardingPassStringParserParameters] required to start the boarding pass image parser feature.\n * @param onParseDocumentCompletion [OnScanBoardingPassCompletion] callback to handle Success and Error scenarios\n */\nfun parseBoardingPass(\n    activity: Activity,\n    params: BoardingPassImageParserParameters,\n    onParseDocumentCompletion: OnScanBoardingPassCompletion,\n)\n</code></pre> <pre><code>func parseBoardingPass(parameters: ParseBoardingPassParameters, viewController: UIViewController, completionHandler: @escaping (Result&lt;BoardingPass, BoardingPassParserError&gt;) -&gt; Void)\n</code></pre> <p>The BoardingPassParserParameters object has the following structure:</p> AndroidiOS <pre><code>/**\n* Parameters for each [BoardingPass] parser operation.\n*\n* @param validate if true, it will perform validation of the [BoardingPass] fields.\n*/\n@Parcelize\nopen class BoardingPassParserParameters(\n    open val validate: Boolean\n) : Parcelable\n\n/**\n* Parameters for each [BoardingPass] parser operation.\n*\n* @param boardingPassData [BoardingPassData] that will that has the barcode raw data and format to be parsed to a [BoardingPass].\n*/\n@Parcelize\ndata class BoardingPassStringParserParameters(\n    val boardingPassData: BoardingPassData,\n    override val validate: Boolean\n) : BoardingPassParserParameters(\n    validate\n)\n\n/**\n* Parameters for each [BoardingPass] parser operation.\n*\n* @param uri URI to an image file of a [BoardingPass] that will be analyzed and parsed.\n*/\n@Parcelize\ndata class BoardingPassImageParserParameters(\n    val uri: Uri,\n    override val validate: Boolean\n) : BoardingPassParserParameters(\n    validate\n)\n</code></pre> <pre><code>public struct ParseBoardingPassParameters {\n    public let validateBoardingPass: Bool\n    public let boardingPassData: BoardingPassData\n    public let boardingPassImage: UIImage?\n\n    public init(validateBoardingPass: Bool,\n                boardingPassData: BoardingPassData,\n                boardingPassImage: UIImage?)\n}\n</code></pre> <p>The BoardingPassData is a model where you will have to provide the raw barcode scan result and the barcode format. Below is the model structure:</p> AndroidiOS <pre><code>@Parcelize\ndata class BoardingPassData(\n    val rawBarcodeData: String,\n    val barcodeFormat: BarcodeFormat\n) : Parcelable\n</code></pre> <pre><code>public struct BoardingPassData {\n    public let rawBarcodeData: String\n    public let barcodeFormat: BarcodeFormat\n\n    public init(rawBarcodeData: String, barcodeFormat: BarcodeFormat)\n}\n</code></pre> <p>BarcodeFormat is an enumeration and it contains the following cases.</p> AndroidiOS <pre><code>enum class BarcodeFormat(val value: String) {\n    AZTEC(\"AZTECCODE\"),\n    PDF417(\"PDF417\"),\n    QR_CODE(\"QR_CODE\"),\n    DATA_MATRIX(\"DataMatrix\")\n}\n</code></pre> <pre><code>public enum BarcodeFormat: String {\n    case aztec\n    case pdf417\n    case qrCode\n    case dataMatrix\n}\n</code></pre>"},{"location":"Features/BoardingPass/BoardingPass_Index.html#handle-result","title":"Handle Result","text":"AndroidiOS <p>You can get the result by registering the callback:</p> <pre><code>interface OnScanBoardingPassCompletion {\n    fun onBoardingPassSuccess(boardingPass: BoardingPass)\n    fun onBoardingPassError(boardingPassError: BoardingPassError)\n}\n</code></pre> <p>In case of a success, the BoardingPass model will be retuned regardless of how you tried to parse/scan:</p> <p>The BoardingPassError has the following structure:</p> <pre><code>data class BoardingPassError(\n    val userCanceled: Boolean,\n    val featureError: FeatureError?\n)\n</code></pre> <p>These method\u2019s completion handler passes a result , where the BoardingPass contains the boarding pass data and BoardingPassScanError contains the possible errors that may occur during the process. Below is an example of usage: <p><pre><code>let parameters = ScanBoardingPassParameters( validateBoardingPass: preferences.useIataStandards())\n\n self.enrolment.scanBoardingPass(parameters: parameters, viewController: vc) { [weak self] result in\n        switch result {\n        case .success(let boardingPass):\n            // Handle Success\n        case .failure(let error):\n            if error.userCanceled {\n                print(\"onUserCancel\")\n            } else {\n                print(error.featureError.publicMessage)\n            }\n        }\n    }\n</code></pre> The BoardingPassScanError and BoardingPassError has the following structure:</p> <pre><code>public class BoardingPassError: Error {\n    public var userCanceled: Bool\n    public var termsAndConditionsAccepted: Bool\n    public var featureError: FeatureError\n}\n</code></pre> <p>In case of success, the BoardingPass has the following structure:</p> AndroidiOS <pre><code>@Parcelize\ndata class BoardingPass(\n    val rawBoardingPass: String,\n    val barcodeType: String,\n    val expiryDate: Date,\n    val formatCode: String,\n    val numberOfLegs: Int,\n    val passengerName: String,\n    val electronicTicketIndicator: String,\n    val beginningOfVersionNumber: String? = null,\n    val versionNumber: Int? = null,\n    val passengerDescription: Int? = null,\n    val checkInSource: String? = null,\n    val boardingPassSource: String? = null,\n    val boardingPassDate: String? = null,\n    val documentType: String? = null,\n    val boardingPassIssuerDesignator: String? = null,\n    val baggageTagNumber: String? = null,\n    val firstNonConsecutiveBaggageTagNumber: String? = null,\n    val secondNonConsecutiveBaggageTagNumber: String? = null,\n    val securityDataBeginning: String? = null,\n    val legs: List&lt;Leg&gt;\n) : Parcelable\n</code></pre> <pre><code>public struct BoardingPass: Codable {\n    public let formatCode: String\n    public let barcodeType: String\n    public let numberOfLegsEncoded: Int\n    public let passengerName: String\n    public let electronicTicketIndicator: String?\n    public let rawBoardingPass: String\n    public let expiryDate: Date\n    public let beginningOfVersionNumber: String?\n    public let versionNumber: Int?\n    public let passengerDescription: String?\n    public let checkInSource: String?\n    public let boardingPassSource: String?\n    public let boardingPassDateString: String?\n    public let documentType: String?\n    public let boardingPassIssuerDesignator: String?\n    public let baggageTagNumber: String?\n    public let firstNonConsecutiveBaggageTagNumber: String?\n    public let secondNonConsecutiveBaggageTagNumber: String?\n    public let securityDataBeginning: String?\n    public let legs: [Leg]\n}\n</code></pre> <p>The Leg has the following structure:</p> AndroidiOS <pre><code>@Parcelize\ndata class Leg(\n    val legOrder: Int,\n    val operatingCarrierPnrCode: String,\n    val originAirportCode: String,\n    val destinationAirportCode: String,\n    val operatingCarrierDesignator: String,\n    val flightNumber: String,\n    val flightDate: String,\n    val compartmentCode: String,\n    val seatNumber: String,\n    val checkInSequenceNumber: String,\n    val passengerStatus: String,\n    val airlineNumericCode: String? = null,\n    val serialNumber: String? = null,\n    val selecteeIndicator: Int? = null,\n    val internationalDocumentVerification: Int? = null,\n    val marketingCarrierDesignator: String? = null,\n    val frequentFlyerAirlineDesignator: String? = null,\n    val frequentFlyerNumber: String? = null,\n    val idAdIndicator: String? = null,\n    val freeBaggageAllowance: String? = null,\n    val fastTrack: String? = null\n) : Parcelable\n</code></pre> <pre><code>public struct Leg: Codable {\n    public let flightNumber: String?\n    public let frequentFlyerNumber: String?\n    public let documentSerialNumber: String?\n    public let airlineNumericCode: String?\n    public let passengerStatus: String?\n    public let sequenceNumber: String?\n    public let seatNumber: String?\n    public let compartmentCode: String?\n    public let flightDate: String?\n    public let legOrder: Int?\n    public let carrierDesignator: String?\n    public let destinationAirport: String?\n    public let originAirport: String?\n    public let carrierPnrCode: String?\n    public let frequentFlyerAirlineDesignator: String?\n    public let selecteeIndicator: Int?\n    public let internationalDocumentVerification: Int?\n    public let marketingCarrierDesignator: String?\n    public let idAdIndicator: String?\n    public let freeBaggageAllowance: String?\n    public let fastTrack: String?\n}\n</code></pre>"},{"location":"Features/BoardingPass/BoardingPass_Index.html#custom-views","title":"Custom Views","text":"<p>The SDK provides default UI solutions for the boarding pass feature flow, as  shown in the following images:</p> <p></p> <p>You can also apply your app\u2019s colors and fonts to these layout solutions, to keep your brand\u2019s image consistent. Check Customization tab to learn more about branding of each view.</p> AndroidiOS <pre><code>@Parcelize\nclass BoardingPassCustomViews(\n    val loadingView: Class&lt;out ICustomBoardingPass.LoadingView&gt;? = null\n) : Parcelable\n</code></pre> <p>Our SDK also allows you to pass your own custom views. The only requirement is that your view must implement the SDK view interfaces. For example, if you want to add a custom loading view, your view class must implement the ICustomBoardingPass.LoadingView interface.</p> <pre><code>public class EnrolmentViewRegister {\n    ...\n    public func registerBoardingPassScannerLoadingView(_ viewType: BoardingPassLoadingViewType)\n\n    ...\n}\n</code></pre> <p>Our SDK also allows you to pass your own custom views. The only requirement is that your view must implement the SDK view protocols. For example, if you want to add a custom loading view, your view class must implement the BoardingPassLoadingViewType.</p> <p>In the customization tab you will also find examples to create your own custom views.</p>"},{"location":"Features/BoardingPass/BoardingPass_LoadingView.html","title":"Loading View","text":"<p>The first view of the Boarding pass flow is the loading view, it appears when the boarding pass feature is initializing.</p> <p></p> <p>It contains a title(1), a message(2), an image(3) and a background that can be customized.</p>"},{"location":"Features/BoardingPass/BoardingPass_LoadingView.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/BoardingPass/BoardingPass_LoadingView.html#text-resources","title":"Text resources","text":"AndroidiOS <p>You can add your own texts and localization by overriding the following string resources: <pre><code>&lt;string name=\"boarding_pass_loading_title_sdk_enrolment\"&gt;Loading settings&lt;/string&gt;\n&lt;string name=\"boarding_pass_loading_subtitle_sdk_enrolment\"&gt;It won\\'t take long&lt;/string&gt;\n</code></pre></p> <p>The best way to override strings is by adding your key through the Theme class <pre><code>Theme.shared.strings.boardingPassScan.initialization\nTheme.shared.strings.boardingPassScan.initializationSubtitle\n</code></pre></p>"},{"location":"Features/BoardingPass/BoardingPass_LoadingView.html#colors","title":"Colors","text":"AndroidiOS <p>You can change the text colors by overriding the following color resource (It affects all texts): <pre><code>&lt;color name=\"colorFaceCaptureTxtDarkSdkEnrolment\"&gt;#1A1C1E&lt;/color&gt;\n</code></pre></p> <p>You can change the background color by overriding the following color resource: <pre><code>&lt;color name=\"colorOverlayFeedbackBgSdkEnrolment\"&gt;#EAEEF6&lt;/color&gt;\n</code></pre></p> <p>You can change the text colors by overriding the following color in Theme class (It affects all Loading Screens): <pre><code>Theme.shared.colors.checkPermission.title\nTheme.shared.colors.checkPermission.subtitle\n</code></pre> You can change the background color by overriding the following color in Theme class(It affects all Loading Screens): <pre><code>Theme.shared.colors.checkPermission.background\n</code></pre></p>"},{"location":"Features/BoardingPass/BoardingPass_LoadingView.html#styles","title":"Styles","text":"AndroidiOS <p>You can extend the styles we use and override any properties (textColor, textSize, fontFamily, etc...) you want. <pre><code>&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Title.Centered\"&gt;\n&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Subtitle.Centered\"&gt;\n</code></pre> Note: It will affect every component that uses the same style.</p> <p>You can change the font through the theme class (this will affect all text in the app): <pre><code>Theme.shared.fonts.bold\nTheme.shared.fonts.regular\n</code></pre></p>"},{"location":"Features/BoardingPass/BoardingPass_LoadingView.html#animation","title":"Animation","text":"AndroidiOS <p>You can change the loading animation by adding a raw json animation file with this name: <pre><code>loading_boardingpass_sdk_enrolment\n</code></pre></p> <p>You can change the loading animation by adding a raw json animation file and overriding the following animation name in Theme class <pre><code>Theme.shared.animations.boardingPass.loadingBoardingPass\n</code></pre></p>"},{"location":"Features/BoardingPass/BoardingPass_LoadingView.html#use-your-own-layouts","title":"Use your own layouts","text":"AndroidiOS <p>To use your own loading screen for boarding pass feature, you need to implement the MobileID SDK Interface for that view.</p> <p>In this case: ICustomBoardingPass.LoadingView <pre><code>interface LoadingView {\n    fun onPreFeatureLoading()\n    fun onFeatureLoading()\n    fun onPostFeatureLoading()\n    fun hideLoading()\n}\n</code></pre> You can use the functions above to change loading screen texts in runtime, or you can opt to ignore those functions.</p> <p>For example create a class BoardingPassLoadingCustomView, create a layout file and bind it.</p> <pre><code>class BoardingPassLoadingCustomView(context: Context) :\nConstraintLayout(context), ICustomBoardingPass.LoadingView {\nprivate var binding: ViewBoardingPassLoadingBinding\n\n    init {\n        binding = ViewBoardingPassLoadingBinding.inflate(LayoutInflater.from(context), this)\n    }\n\n    override fun onPreFeatureLoading() {\n        // Do nothing\n    }\n\n    override fun onFeatureLoading() {\n        // Do nothing\n    }\n\n    override fun onPostFeatureLoading() {\n        // Do nothing\n    }\n\n    override fun hideLoading() {\n        // Do nothing\n    }\n}\n</code></pre> <p>You need to register a class of type BoardingPassLoadingViewType through the following function of EnrolmentViewRegister <pre><code>public func registerBoardingPassScannerLoadingView(_ viewType: BoardingPassLoadingViewType)\n</code></pre></p> <p>The BoardingPassLoadingViewType class needs to respect the following protocols:</p> <pre><code>public protocol BoardingPassLoadingViewInterface: FeatureLoadingView {}   \n\npublic typealias BoardingPassLoadingViewType = BoardingPassLoadingView.Type\npublic typealias BoardingPassLoadingView = UIView &amp; BoardingPassLoadingViewInterface\n\npublic protocol FeatureLoadingViewInterface {\n    func onPreFeatureLoading()\n    func onPostFeatureLoading()\n    func hideLoading()\n}\n\npublic typealias FeatureLoadingViewType = FeatureLoadingView.Type\npublic typealias FeatureLoadingView = UIView &amp; FeatureLoadingViewInterface\n</code></pre> <p>Example: <pre><code>class LoadingView: BoardingPassLoadingView {\n\n// MARK: - Initialization\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        //add any UI customization you need\n    }\n\n// MARK: - Functions\n\n    func onPreFeatureLoading() {\n        //add any UI customization you need\n    }\n\n    func onPostFeatureLoading() {\n        //add any UI customization you need\n    }   \n\n    func hideLoading() {\n        //You can stop animations or other activities that consumes resources \n    }\n}\n</code></pre></p>"},{"location":"Features/BoardingPass/BoardingPass_PreviewView.html","title":"Preview View","text":"<p>From version 8 onwards, the preview management changed in the SDK to make it easier to integrate.</p> <p>To improve flexibility in the preview screen, the optional preview screen has been removed.</p> <p>To add a preview feature to your app you can follow the example from our sample app, where we provide an example with the same user interface.</p> AndroidiOS <p>Example can be found here: BoardingPassPreview</p> <p>Example can be found here: Sample Project</p>"},{"location":"Features/BoardingPass/BoardingPass_ScanView.html","title":"Scan View","text":"<p>The second view of the Boarding pass flow is the scan view, it's the camera screen that detects the boarding pass barcode.</p> <p></p> <p>It contains a cancel button (1), a title(2), a message(3) and a frame(4) that can be customized.</p>"},{"location":"Features/BoardingPass/BoardingPass_ScanView.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/BoardingPass/BoardingPass_ScanView.html#text-resources","title":"Text resources","text":"AndroidiOS <p>You can add your own texts and localization by overriding the following string resources <pre><code>&lt;string name=\"boarding_pass_loading_bt_scan_sdk_enrolment\"&gt;Scan boarding pass&lt;/string&gt; &lt;!--Title --&gt;\n&lt;string name=\"boarding_pass_scan_subtitle_sdk_enrolment\"&gt;Looking for barcode or QR code\u2026&lt;/string&gt; &lt;!-- Subtitle --&gt;\n</code></pre></p> <p>The best way to override strings is by adding your key through the Theme class <pre><code>Theme.shared.strings.boardingPassScan.scanTilte\nTheme.shared.strings.boardingPassScan.scanSubtilte\n</code></pre></p>"},{"location":"Features/BoardingPass/BoardingPass_ScanView.html#colors","title":"Colors","text":"AndroidiOS <p>You can change the text colors by overriding the following color resource (It affects all texts) <pre><code>&lt;color name=\"colorFaceCaptureTxtLightSdkEnrolment\"&gt;#DFFFFFFF&lt;/color&gt;\n</code></pre></p> <p>You can change the background color by overriding the following color resource <pre><code>&lt;color name=\"colorBarcodeScanBgSdkEnrolment\"&gt;#000000&lt;/color&gt;\n</code></pre></p> <p>You can change the text colors by overriding the following color in Theme class(affects both title and subtitle): <pre><code>Theme.shared.colors.boardingPassScan.title\n</code></pre> You can change the color of the mask (also affects BiometricFaceCapture): <pre><code>Theme.shared.colors.component.transparentOverlay\n</code></pre> You can change the color of the frame (also affects Face Capture and Document Reader) <pre><code>Theme.shared.colors.common.black\n</code></pre></p>"},{"location":"Features/BoardingPass/BoardingPass_ScanView.html#styles","title":"Styles","text":"AndroidiOS <p>You can extend the style we use and override any properties (textColor, textSize, fontFamily, etc...) you want. <pre><code>&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Title.Centered\"&gt;\n&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Subtitle.Centered\"&gt;\n</code></pre> Note: It will affect every component that uses the same style.</p> <p>You can change the font through the theme class (this will affect all text in the app): <pre><code>Theme.shared.fonts.regular\n</code></pre></p>"},{"location":"Features/BoardingPass/BoardingPass_ScanView.html#images","title":"Images","text":"AndroidiOS <p>You can change the cancel button icon by adding a drawable with this name: <pre><code>ic_cancel_sdk_enrolment.xml\n</code></pre> The image we are using is 24x24dp</p> <p>You can change the frame by adding a drawable with this name: <pre><code>barcode_scan_mask_sdk_enrolment.xml\n</code></pre> The image we are using is 320x320dp</p> <p>You can change the image by adding a asset file and overriding the following image name in Theme class <pre><code>Theme.shared.images.buttons.closeButton // It affects all close buttons\n</code></pre></p>"},{"location":"Features/Common/ComposeSupport.html","title":"Jetpack Compose Custom Views","text":"<p>In Android, there's a new way to create the layouts programmatically using Jetpack compose library. Our layouts are currently in traditional XML files but we also want to give the option to use compose when needed. This page will briefly explain how you can wrap a composable in a xml layout to use it as a custom view.</p>"},{"location":"Features/Common/ComposeSupport.html#create-a-composable-wrapper-layout-file","title":"Create a Composable Wrapper layout file","text":"<p>First we are going to need a layout file that contains a compose view.</p> <p>Since we want to make the whole screen a composable, then it's as simple as adding a Compose View that takes the whole space. Create a new layout file, call it, for example, composable_wrapper.xml and paste the following code there:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;merge\nxmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"match_parent\"\ntools:parentTag=\"androidx.constraintlayout.widget.ConstraintLayout\"&gt;\n\n    &lt;androidx.compose.ui.platform.ComposeView\n        android:id=\"@+id/compose_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"&gt;\n\n    &lt;/androidx.compose.ui.platform.ComposeView&gt;\n\n&lt;/merge&gt;\n</code></pre> <p>Now that we have the composable wrapper, this layout file can be used for all the custom views you want to implement.</p> <p>For example, let's implement the document reader loading as a composable custom view.</p>"},{"location":"Features/Common/ComposeSupport.html#create-the-custom-view-class","title":"Create the custom view class","text":"<p>Create a new class, let's call it CustomLoadingView that's going to extend a ConstraintLayout.</p> <p>Paste the following code and make sure to import everything you need.</p> <pre><code>class CustomLoadingView(context: Context) : ConstraintLayout(context), ICustomDocumentReader.LoadingView { \n    private val binding: ComposeWrapperBinding\n    private var isLoading by mutableStateOf(false)\n    private var title by mutableStateOf(\"\")\n    private var message by mutableStateOf(\"\")\n\n    init {\n        binding = ComposeWrapperBinding.inflate(\n            LayoutInflater.from(context),\n            this\n        )\n        binding.composeView.setContent {\n            LoadingViewCompose()\n        }\n    }\n\n    override fun onPreFeatureLoading(message: String) {\n        isLoading = true\n        title = \"Loading...\"\n        this.message = message\n    }\n\n    override fun onPostFeatureLoading() {\n        isLoading = false\n        title = \"\"\n        this.message = \"\"\n    }\n\n    override fun onDownloadProgressChanged(progress: Int) {\n        isLoading = true\n        title = \"Downloading Resources\"\n        this.message = \"Progress: $progress%\"\n    }\n\n    override fun hideLoading() {\n        isLoading = false\n        title = \"\"\n        this.message = \"\"\n    }\n\n    @Composable\n    fun LoadingViewCompose() {\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(16.dp),\n            verticalArrangement = Arrangement.Center,\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            if (isLoading) {\n                // Show loading progress indicator\n                CircularProgressIndicator()\n            }\n            // Show title and message\n            Text(\n                text = title,\n                color = Color.Black,\n                fontSize = 20.sp,\n                textAlign = TextAlign.Center,\n                modifier = Modifier.padding(bottom = 8.dp)\n            )\n            Text(\n                text = message,\n                color = Color.Gray,\n                fontSize = 16.sp,\n                textAlign = TextAlign.Center,\n                modifier = Modifier.padding(bottom = 16.dp)\n            )\n        }\n    }\n}\n</code></pre> <p>Breaking this code down, we have a constraint layout, that implements the loading view contract, changing the values of the spinner, title and message according to what is happening in the moment.  Basically the same we would have with a traditional xml custom view.</p> <p>The difference comes in the composable function, that's a very simple UI to serve as an example.  It contains a spinner which visibility is controlled by a state variable. And two text fields which value will also change during the execution.</p> <p>In the constructor of this class, we make sure to inflate the composable wrapper we added in the first place and pass the composable into the ComposeView.</p>"},{"location":"Features/Common/ComposeSupport.html#pass-the-custom-view-into-the-builder","title":"Pass the custom view into the builder","text":"<p>After this class is created and configured, we need to inject it to the custom views list as we do with regular custom views as well.</p> <pre><code>val enrolmentModule = module {\n    single&lt;IEnrolment&gt; {\n        EnrolmentBuilder.of(\n            context = this@ComposeApp,\n            config = enrolmentConfig\n        ).withDocumentReaderConfig(documentReaderConfig)\n            .withDocumentReaderCustomViews(\n                DocumentReaderCustomViews(\n                    loadingView = CustomLoadingView::class.java\n                )\n            ).build()\n    }\n}\n</code></pre> <p>And that's it, when you run the document reader feature, the loading screen will show up using the UI defined in the composable.</p>"},{"location":"Features/Common/HandleErrors.html","title":"Error handling","text":"<p>From version 8 onwards, the errors management changed in the SDK to make it easier to integrate.</p> <p>To improve flexibility in error handling, the optional error screen has been removed.</p> <p>A new example has been added to our sample app with the same user interface for error handling.</p> <p>You can easily implement your own error handling logic without needing to customize our screen by following the example on each feature -&gt; Handle errors tab</p>"},{"location":"Features/Common/HandleErrors.html#error-object-and-properties","title":"Error object and properties","text":"<p>Every feature, will send a FeatureError object detailing what happened when something outside the normal flow occurs.</p> <p>The FeatureError has the following structure:</p> AndroidiOS <pre><code>/***\n* @param errorType - Enum that classifies the error type\n* @param errorCode - Error code that identifies the error\n* @param description - Error description for log purposes\n* @param publicMessage - Error message suggestion to display in error screens\n*/\n@Parcelize\ndata class FeatureError(\n    val errorType: ErrorType,\n    val errorCode: Int,\n    val description : String,\n    val publicMessage : String = \"\"\n) : Parcelable\n</code></pre> <pre><code>enum class ErrorType {\n    InternalError,\n    CommunicationError,\n    PermissionNotGrantedError,\n    UserCanceled,\n    ScanError,\n    Timeout,\n    BoardingPassInvalidError,\n    DocumentReaderError,\n    FaceCaptureError,\n    FaceMatchError,\n    SubjectError,\n    FormError,\n    UnknownError,\n    ConfigurationError,\n    BadConfigurationError\n}\n</code></pre> <pre><code>///\n/// - Parameters:\n///     - errorType: Enum that classifies the error type\n///     - errorCode: Error code that identifies the error\n///     - description: Error description for log purposes\n///     - publicMessage: Error message suggestion to display in error screens\n\npublic class FeatureError: Error {\n    public let errorType: ErrorType\n    public let errorCode: Int\n    public let description: String\n    public let publicMessage: String\n\n    init(errorType: ErrorType, errorCode: Int, description: String, publicMessage: String, name: String) \n}\n\npublic enum ErrorType {\n    case internalError\n    case communicationError\n    case termsAndConditionsRejected\n    case userRepeated\n    case permissionNotGrantedError\n    case scanError\n    case scanTimeout\n    case boardingPassInvalid\n    case faceCaptureError\n    case faceMatchError\n    case subjectError\n    case unknownError\n}\n</code></pre> <p>Here you can find a list of all the error codes the SDK sends to the client application:</p> Name Value Feature InvalidApiKey 010 Configuration InvalidEndpoint 011 Configuration InitFailed 012 Configuration NotReady 013 Configuration NotReady 014 Configuration ConfigError 100 DocumentReader NotReady 101 DocumentReader InitFailed 102 DocumentReader ReportIsNull 103 DocumentReader ErrorCertificate 104 DocumentReader InvalidCertificate 105 DocumentReader LicenseNotFound 106 DocumentReader PermissionNotGranted 107 DocumentReader FetchingResourcesFailed 120 DocumentReader TransactionFailed 121 DocumentReader InvalidDatabaseState 122 DocumentReader ProviderNotFound 140 DocumentReader InvalidParameters 141 DocumentReader MrzError 150 DocumentReader RegulaError 151 DocumentReader MrzTimeout 152 DocumentReader RFIDError 153 DocumentReader GenericError 170 DocumentReader PAError 171 DocumentReader MRZRFIDMismatch 172 DocumentReader UnknownError 180 DocumentReader ConfigError 200 BoardingPassScan BarcodeUnsupported 201 BoardingPassScan PermissionNotGranted 202 BoardingPassScan BoardingPassNull 203 BoardingPassScan CameraInitFailed 204 BoardingPassScan TransactionFailed 220 BoardingPassScan CameraPermissionNotGranted 230 BoardingPassScan BoardingPassScanFailed 250 BoardingPassScan BoardingPassItemParserError 251 BoardingPassScan BoardingPassInvalid 252 BoardingPassScan BarcodeEmpty 253 BoardingPassScan UnknownError 280 BoardingPassScan ConfigError 300 BoardingPassParse BarcodeUnsupported 301 BoardingPassParse PermissionNotGranted 302 BoardingPassParse BoardingPassNull 303 BoardingPassParse TransactionFailed 320 BoardingPassParse BoardingPassItemParserError 350 BoardingPassParse BoardingPassInvalid 351 BoardingPassParse BarcodeEmpty 352 BoardingPassParse BoardingPassImageNoBarcodeFound 353 BoardingPassParse BoardingPassImageParseError 354 BoardingPassParse UnknownError 380 BoardingPassParse PermissionNotGranted 400 FaceCapture ErrorLoadingImageFromStorage 401 FaceCapture PermissionNotGranted 402 FaceCapture ErrorLoadingImageFromStorage 403 FaceCapture PermissionNotGranted 404 FaceCapture ErrorLoadingImageFromStorage 405 FaceCapture PermissionNotGranted 406 FaceCapture ErrorLoadingImageFromStorage 407 FaceCapture PermissionNotGranted 420 FaceCapture ErrorLoadingImageFromStorage 422 FaceCapture PermissionNotGranted 430 FaceCapture InvalidParameters 440 FaceCapture ErrorLoadingImageFromStorage 450 FaceCapture PermissionNotGranted 451 FaceCapture ErrorLoadingImageFromStorage 452 FaceCapture UnknownError 480 FaceCapture PermissionNotGranted 500 FaceMatch ErrorLoadingImages 501 FaceMatch TransactionFailed 520 FaceMatch CommunicationError 521 FaceMatch MatchFailed 550 FaceMatch DataIntegrityFailed 551 FaceMatch UnknownError 580 FaceMatch PermissionNotGranted 600 Subject DataError 601 Subject TransactionFailed 620 Subject CommunicationError 621 Subject SubjectServiceError 650 Subject MissingBCBP 651 Subject UnknownError 680 Subject PermissionNotGranted 800 Form TransactionFailed 820 Form CommunicationError 821 Form FormServiceError 850 Form UnknownError 880 Form <p>You can use the result code to provide accurate feedback to the user or use the new property inside FeatureError, called errorType that classifies the type of error. We suggest that errors should be handled by errorType.</p> <p>Alongside with the error code and description that are useful for logging and tracing, we also provide a publicErrorMessage that is a suggestion of what you can show to the final user as an error message.</p> <p>The value of publicErrorMessage is filled depending on the error type and you can change the default texts or provide additional translations by overriding these strings:</p> AndroidiOS <pre><code>&lt;string name=\"error_internal_sdk_enrolment\"&gt;Oops! There was an unexpected error, please contact support.&lt;/string&gt;\n&lt;string name=\"error_communication_sdk_enrolment\"&gt;There was an error while communicating with the server, please try again.&lt;/string&gt;\n&lt;string name=\"error_android_permission_sdk_enrolment\"&gt;The required permission was not given.&lt;/string&gt;\n&lt;string name=\"error_scan_failed_sdk_enrolment\"&gt;There was an error with the scan, please try again.&lt;/string&gt;\n&lt;string name=\"error_document_reader_timeout_sdk_enrolment\"&gt;Oops! You took too long, please try again.&lt;/string&gt;\n&lt;string name=\"error_boarding_pass_invalid_sdk_enrolment\"&gt;The boarding pass is invalid.&lt;/string&gt;\n&lt;string name=\"error_face_capture_failed_sdk_enrolment\"&gt;We were unable to detect a face, please try again.&lt;/string&gt;\n&lt;string name=\"error_face_match_failed_sdk_enrolment\"&gt;The images don\\'t match, please redo the process.&lt;/string&gt;\n&lt;string name=\"error_subject_failed_sdk_enrolment\"&gt;We were unable to identify the related subject.&lt;/string&gt;\n&lt;string name=\"error_canceled_sdk_enrolment\"&gt;The user chose to cancel the operation.&lt;/string&gt;\n&lt;string name=\"error_repeated_sdk_enrolment\"&gt;The user repeated the operation.&lt;/string&gt;\n&lt;string name=\"error_terms_and_conditions_rejected_sdk_enrolment\"&gt;Unfortunately, since you did not accept the terms and conditions we can\\'t proceed.&lt;/string&gt;\n&lt;string name=\"error_unknown_sdk_enrolment\"&gt;Oops! An unidentified problem occurred, please try again.&lt;/string&gt;\n</code></pre> <pre><code>//configurationError\nTheme.shared.strings.errorsPublicMessages.configError\n//internalError\nTheme.shared.strings.errorsPublicMessages.internalError\n//communicationError\nTheme.shared.strings.errorsPublicMessages.communicationError\n//termsAndConditionsRejected\nTheme.shared.strings.errorsPublicMessages.termsAndConditionsRejected\n//userRepeated\nTheme.shared.strings.errorsPublicMessages.userRepeated\n//permissionNotGrantedError\nTheme.shared.strings.errorsPublicMessages.permissionNotGrantedError\n//scanError\nTheme.shared.strings.errorsPublicMessages.scanError\n//scanTimeout\nTheme.shared.strings.errorsPublicMessages.scanTimeout\n//boardingPassInvalid\nTheme.shared.strings.errorsPublicMessages.boardingPassInvalid\n//faceCaptureError\nTheme.shared.strings.errorsPublicMessages.faceCaptureError\n//faceMatchError\nTheme.shared.strings.errorsPublicMessages.faceMatchError\n//subjectError\nTheme.shared.strings.errorsPublicMessages.subjectError\n//unknownError\nTheme.shared.strings.errorsPublicMessages.unknownError\n</code></pre>"},{"location":"Features/Common/HandleErrors.html#how-to-setup-error-handling","title":"How to setup error handling","text":"<p>When you call one of our facade methods, then you will need to pass a completion handler, and it will be called when the result is ready, either successfully or with an error.</p> <p>You can check more details how to obtain the FeatureError object on the \"Handle result\" section of the overview page of each feature.</p> <p>This is a brief overview of what each ErrorType corresponds to:</p> <ul> <li>When it's an internal error, you have to contact VisionBox and share some stacktrace or way to replicate the bug. It usually means that there is some invalid configuration or missing property from our backoffice.</li> <li>Communication errors are mostly caused by internet connection issues, so trying again can solve the problem, it's recommended to allow the user to re-send the request. It can also mean an invalid url of some sort, so if the problem persists you can contact VisionBox.</li> <li>PermissionNotGrantedError means that the user didn't grant permission to use some part of the hardware that is required, as recommended you should have a rationale to explain why that permission is required and block the user from proceeding until he grants the permission.</li> <li>User repeated and user canceled are not exactly errors, they are just warnings to inform that the user wants to try again or canceled the operation.</li> <li>Scan error happens when there is a regula error or any error with the scan of the boarding pass, this usually requires debugging, so it's recommended to share the stacktrace and communicate to VisionBox.</li> <li>Timeout it means that either the timer of document reader or face capture has reached the end and it wasn't possible to capture the image successfully, you can inform the user of that, suggesting how he should scan the document (on the table, with a high contrast from the table, with the proper angle etc..), or take the selfie in better conditions and let the user try again.</li> <li>Boarding pass invalid means that the scan or parse of the boarding pass was correct but some issues were found. Can be the format that is not supported by us, or simply it's not actually a boarding pass barcode.</li> <li>FaceCaptureError means that the feature failed, either due to our quality tests failing, and in that case you will receive a report saying which tests failed, or liveness service failed due to the quality of the image or being a image of an image and not a real person.</li> <li>SubjectError happens when the subject action the user was trying to make failed. eg: User tried to add an invalid subject.</li> <li>Unknown errors should not happen but any error that we have unmapped will return unknown error and must be reported for investigation.</li> </ul>"},{"location":"Features/DocumentReader/DocumentReader_FindChipView_Android.html","title":"Find Chip View","text":"<p>It contains a title(1), a message(2), an animation(3), a skip Button(4) and a background that can be customized. </p>"},{"location":"Features/DocumentReader/DocumentReader_FindChipView_Android.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/DocumentReader/DocumentReader_FindChipView_Android.html#text-resources","title":"Text resources","text":"<p>You can add your own texts and localization by overriding the following string resources:</p> <pre><code>&lt;resources&gt;\n    &lt;string name=\"rfid_read_title_sdk_enrolment\"&gt;Find document chip&lt;/string&gt;\n    &lt;string name=\"rfid_read_subtitle_sdk_enrolment\"&gt;Slowly move your phone on top of your document to align the phone antenna and document chip&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_FindChipView_Android.html#colors","title":"Colors","text":"<p>You can change the colors of text elements and the background by overriding the following color resource (It affects all texts):</p> <pre><code>&lt;resources&gt;\n    &lt;!-- Change the text color --&gt;\n    &lt;color name=\"colorFaceCaptureTxtDarkSdkEnrolment\"&gt;#1A1C1E&lt;/color&gt;\n    &lt;!-- Change the background color --&gt;\n    &lt;color name=\"colorDocumentReadRFIDBgSdkEnrolment\"&gt;#EAEEF6&lt;/color&gt;\n&lt;/resources&gt;\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_FindChipView_Android.html#styles","title":"Styles","text":"<p>You can extend the styles we use and override any properties (textColor, textSize, fontFamily, etc...) you want. <pre><code>&lt;resources&gt;\n    &lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Title.Centered\"&gt;&lt;/style&gt;\n    &lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Subtitle.Centered\"&gt;&lt;/style&gt;\n&lt;/resources&gt;\n</code></pre> Note: It will affect every component that uses the same style.</p>"},{"location":"Features/DocumentReader/DocumentReader_FindChipView_Android.html#animation","title":"Animation","text":"<p>You can change the animation by adding a raw json animation file with this name:</p> <ul> <li>chip_read_reading_sdk_enrolment.json</li> </ul>"},{"location":"Features/DocumentReader/DocumentReader_FindChipView_Android.html#use-your-own-layouts","title":"Use your own layouts","text":"<p>To use your own custom screens for document reader feature, you need to implement the MobileID SDK Interface for that view. In this case: ICustomDocumentReader.RfidSearchView <pre><code>interface RfidSearchView {\n    fun getSkipButton(): View?\n    fun hideSearch()\n}\n</code></pre></p> <p>getSkipButton should return a button view to allow the user to skip Chip reading, if you don't want this to be possible, simply return null here. hideSearch is called when the view is dismissed to allow you to clean your variables and stop animations. </p> <p>For example create a class RfidReadCustomView, create a layout file and bind it.</p> <pre><code>class RfidReadCustomView(\n    context: Context\n) : ConstraintLayout(context), ICustomDocumentReader.RfidReadView {\n    private var binding: ViewRfidReadBinding\n\n    init {\n        binding = ViewRfidReadBinding.inflate(LayoutInflater.from(context), this)\n    }\n\n    override fun getSkipButton() = binding.btnSkip\n    override fun hideSearch() {\n        // Do nothing\n    }\n}\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_HandleErrors.html","title":"Handle Errors","text":"<p>After obtaining the FeatureError, as shown in the Handle Result section of the feature overview, we pass the object to the handleError function that is going to analyze what error type occurred in this feature and act according to it.</p> AndroidiOS <p>Example can be found here: DocumentReaderHandleErrors <pre><code>private fun handleError(error: BoardingPassError?) {\n    if (error != null) {\n        val errorType = error.featureError?.errorType ?: ErrorType.UnknownError\n        when (errorType) {\n            ErrorType.InternalError -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", false)\n            }\n            ErrorType.CommunicationError,\n            ErrorType.PermissionNotGrantedError,\n            ErrorType.Timeout,\n            ErrorType.ScanError -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", true)\n            }\n            ErrorType.UserRepeated -&gt; {\n                retry()\n            }\n            ErrorType.UserCanceled -&gt; {\n                // User canceled the flow\n                finish()\n            }\n            else -&gt; {\n                Toast.makeText(this, \"An unknown error occurred\", Toast.LENGTH_SHORT).show()\n                finish()\n            }\n        }\n    }\n}\n</code></pre> The boolean in the navigateToErrorScreen function is to configure if the retry button should appear or not.</p> <p>Example can be found here: Sample Project</p>"},{"location":"Features/DocumentReader/DocumentReader_Index.html","title":"Document Reader","text":"<p>The document reader is used to extract the user\u2019s document information and perform all necessary security validations. This functionality works in two steps: the MRZ of the travel document is scanned (using the device's camera) and then, if it is an electronic document (i.e. with a chip), and the client app indicated that it wants to read the chip, the user is prompted to place the mobile device over the travel e-Document in order to perform a RFID scan to extract available data.</p>"},{"location":"Features/DocumentReader/DocumentReader_Index.html#configure","title":"Configure","text":"<p>To use this feature, you must provide the DocumentReaderConfig to your preferred Provider like the following example:</p> AndroidiOS <pre><code>val provider: RegulaProvider = RegulaProvider.getInstance(documentReaderConfig)\n</code></pre> <pre><code>var provider = RegulaDocumentReaderScan(config: documentReaderConfig)\n</code></pre> <p>The DocumentReaderConfig has the following structure:</p> AndroidiOS <pre><code>data class DocumentReaderConfig(\n  val multipageProcessing: Boolean,\n  val databaseId: String,\n  val checkHologram: Boolean = false,\n  val scenario: DocumentReaderScenario = DocumentReaderScenario.OCR\n) : Parcelable\n</code></pre> <ul> <li>multipageProcessing: controls the workflow for documents that might need to have different pages scanned;</li> <li>databaseId: specify database Id to be used with the document reader functionality (provided by Regula);</li> <li>checkHologram: checks the presence of holographic effect on the document</li> <li>scenario: the process in which the document is captured</li> </ul> <pre><code>enum class DocumentReaderScenario(val scenario: String) {\n    OCR(Scenario.SCENARIO_OCR),\n    MRZ(Scenario.SCENARIO_MRZ),\n}\n</code></pre> <pre><code>public struct DocumentReaderConfig {\n    public let multipageProcessing: Bool\n    public let databaseID: String\n    public let databasePath: String?\n    public let scannerTimeout: TimeInterval\n    public let checkHologram: Bool\n    public let scenario: DocumentReaderScenario\n\n    public init(multipageProcessing: Bool, databaseID: String, databasePath: String? = nil, scannerTimeout: TimeInterval = 30, checkHologram: Bool = false, scenario: DocumentReaderScenario = .ocr)\n}\n\npublic enum DocumentReaderScenario: CaseIterable {\n    case ocr\n    case mrz\n\n    public var value: String {\n        switch self {\n        case .ocr:\n            return \"RGL_SCENARIO_OCR\"\n        case .mrz:\n            return \"RGL_SCENARIO_MRZ\"\n        }\n    }\n}\n</code></pre> <ul> <li>multipageProcessing: controls the workflow for documents that might need to have different pages scanned;</li> <li>databaseId: specify database Id to be used with the document reader functionality (provided by Regula);</li> <li>databasePath: Database path for .dat file to initialize Regula documents database. Default value is <code>nil</code>.</li> <li>scannerTimeout: Document scan timeout, in seconds. Default value is <code>30</code> seconds.</li> <li>checkHologram: Indicates whether or not the document reader supports Hologram Reading</li> <li>scenario: Changes the scanning scenario in which the document is captured</li> </ul>"},{"location":"Features/DocumentReader/DocumentReader_Index.html#initiate-scan","title":"Initiate Scan","text":"<p>The document reader functionality enables the client application to extract and validate data from travel documents from different countries, by calling the readDocument method.</p> AndroidiOS <pre><code>/**\n * Reads the information contained in a personal document.\n *\n * @param activity [Activity] that will launch the face capture feature\n * @param params [DocumentReaderParameters] with some configurations for the document reader feature.\n * @param onReadDocumentCompletion [OnReadDocumentCompletion] callback to handle Success and Error scenarios\n */\nfun readDocument(\n    activity: Activity,\n    params: DocumentReaderParameters,\n    onReadDocumentCompletion: OnReadDocumentCompletion,\n)\n</code></pre> <pre><code>    func readDocument(parameters: ReadDocumentParameters, \n                      viewController: UIViewController, \n                      completionHandler: @escaping (Result&lt;DocumentReaderReport, DocumentReaderError&gt;) -&gt; Void) throws\n</code></pre> <p>This method can perform a full travel document read in two steps:</p> <ul> <li>MRZ scan: using the device's camera, the SDK reads the MRZ section of the travel document and   extracts information from it. During this step, and if available, a document picture is also   scanned and saved.</li> <li>RFID scan: the user is prompted to move the device over the e-Document and, using NFC, the chip   data is scanned. This step is available only for electronic documents (i.e. with a chip) and is   optional (i.e. the client app must indicate that it wants to read the document's chip, setting the   readRFID flag to true when calling the readDocument method). You can use specific parameters when   using this functionality for passport scanning. Below is an example on how to provide those   parameters:</li> </ul> AndroidiOS <pre><code>data class DocumentReaderParameters(\n  val rfidRead: Boolean,\n  @IntRange(from = 10_000, to = 60_000)\n  val mrzReadTimeout: Long = TimeUnit.SECONDS.toMillis(30),\n  @IntRange(from = 10_000, to = 60_000)\n  val rfidReadTimeout: Long = TimeUnit.SECONDS.toMillis(30),\n  val showRFIDInstructions: Boolean = true,\n) : Parcelable\n</code></pre> <pre><code>public struct ReadDocumentParameters {\n    public let readRFID: Bool\n    public let showRFIDStatus: Bool\n    public let scannerTimeout: TimeInterval\n    public let rfidTimeout: TimeInterval\n    public let showRFIDInstructions: Bool\n\n    public init(readRFID: Bool,\n                showRFIDStatus: Bool = false,\n                scannerTimeout: TimeInterval = 30,\n                rfidTimeout: TimeInterval = 30,\n                showRFIDInstructions: Bool = true\n    )\n}\n</code></pre> <p>Both mrzReadTimeout and rfidReadTimeout values must be between 10 and 60 seconds, otherwise an InvalidParameters error will occur. It's no longer possible to disable either of this timeout.</p> <p>If both scans are enabled and the RFID scan fails for some reason, the MRZ scan data is always returned as the default set of data read from the travel document. The mrzReadTimeout is the timeout value in seconds before closing the document reading screen if no document is scanned during this period.</p> <p>The showRFIDInstructions field, when set to false, allows the RFID Scan to start automatically as soon as the document has been read using OCR successfully, not showing the instructions screen when using it nor giving the chance to skip rfid scan.</p> <p>It's also possible to implement your own OCR scan and then use our DocumentReader just for the RFID reading process. For this, you will need to pass the DocumentReaderRFIDParameters and call the readDocumentRFID facade method:</p> AndroidiOS <pre><code>data class DocumentReaderRFIDParameters(\n  @IntRange(from = 10_000, to = 60_000)\n  val rfidReadTimeout: Long = TimeUnit.SECONDS.toMillis(30),\n  val showRFIDInstructions: Boolean = true,\n  val mrzString: String\n) : Parcelable\n</code></pre> <pre><code>public struct ReadRFIDDocumentParameters {\n    public let documentNumber: String\n    public let documentMRZ: String\n    public let dateOfExpiry: Date\n    public let dateOfBirth: Date\n    public let showRFIDStatus: Bool\n    public let rfidTimeout: TimeInterval\n    public let showRFIDInstructions: Bool\n\n    public init(documentNumber: String,\n            documentMRZ: String,\n            dateOfExpiry: Date,\n            dateOfBirth: Date,\n            showRFIDStatus: Bool = false,\n            rfidTimeout: TimeInterval = 30\n    ) \n}\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_Index.html#handle-result","title":"Handle Result","text":"<p>Here is how you can get the document reader report and handle the result for document reader:</p> AndroidiOS <p>You can get the result by registering the callback <pre><code>interface OnReadDocumentCompletion {\n    fun onReadDocumentSuccess(documentReaderReport: DocumentReaderReport)\n    fun onReadDocumentError(documentReaderError: DocumentReaderError)\n}\n</code></pre></p> <p>The DocumentReaderError has the following structure:</p> <pre><code>data class DocumentReaderError(\n    val userCanceled: Boolean,\n    val featureError: FeatureError?,\n)\n</code></pre> <p><pre><code>self.enrolment.readDocument( parameters: parameters, viewController: view) { [weak self] result in\n    switch result {\n        case .success(let documentReaderReport):\n           // handle DocumentReaderReport\n\n        case .failure(let error):\n            if error.userCanceled {\n                print(\"onUserCancel\")\n            } else {\n                print(error.featureError.publicMessage)\n            }\n        }\n    }\n}\n</code></pre> The DocumentReaderError has the following structure:</p> <pre><code>public class DocumentReaderError: Error {\n    public var userCanceled: Bool\n    public var termsAndConditionsAccepted: Bool\n    public var featureError: FeatureError\n}\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_Index.html#document-reader-report","title":"Document Reader Report","text":"AndroidiOS <pre><code>@Serializable\ndata class DocumentReaderReport(\n  val documentData: DocumentData,\n  val idDocument: IdDocument,\n  val status: List&lt;DocumentDataStatus&gt;,\n  val rfidStatus: RFIDStatus,\n  val documentType: DocumentType,\n  val documentPhotoHash: String, // Portrait Image\n  val documentDataHash: String, // DocumentData object\n  val idDocumentHash: String, // IdDocument object\n) : Parcelable\n</code></pre> <pre><code>public struct DocumentReaderReport: Codable {\n    public let documentData: DocumentData\n    public let documentType: DocumentType\n    public let idDocument: IdDocument\n    public let documentRFIDStatus: DocumentRFIDStatus\n    public let documentStatuses: [DocumentDataStatus]\n    public let documentPhotoHash: String?\n    public let documentDataHash: String?\n    public let idDocumentHash: String?\n}\n</code></pre> <p>The <code>DocumentReaderReport</code> includes three hash fields that that are used to verify data integrity when building a Subject.</p> <p>The DocumentData is now deprecated and will be removed in the next major version.</p> <p>Instead, we recommend to start using the IdDocument class that contains more information with different sources depending on the document type. </p> <p>You can check the structure here:</p> AndroidiOS <p><pre><code>data class IdDocument(\n  val info: InfoSection? = null,\n  val data: DataSection? = null,\n  val viz: VIZSection? = null,\n  val mrz: MRZSection? = null,\n  val rfid: RFIDSection? = null,\n  val validations: Validations? = null\n): Parcelable\n</code></pre> <pre><code>data class InfoSection(\n  val id: Int? = null, // A unique identifier for the document.\n  val documentName: String? = null, // Indicates the type and issuing country of the document\n  val icaoCode: String? = null, // The International Civil Aviation Organization code for the issuing country.\n  val type: String? = null, // Enum: ['P', 'I', 'D', 'C'], Passport, ID card, Drivers license, C?\n  val isElectronic: Int? = null, // Based on the chip page, will indicate if the document is electronic. Enum: [0, 1, 2] Description:  \u2022 0: not electronic  \u2022 1: Electronic  \u2022 2: Unknown\n  val chipPage: Int? = null, // Determines the presence and location of an RFID chip in a document. Enum: [0, 1, 2, 3] Description:  0: no chip; 1: chip is located in the document data page; 2: chip is located in the back page or inlay of the document; 3: Unknown\n): Parcelable\n</code></pre> <pre><code>/**\n  * Data priority: chip &gt; MRZ &gt; VIZ\n*/\ndata class DataSection(\n  val mrzString: String? = null, // Combined raw MRZ data string.\n  val docType: String? = null, // Combined document type (e.g., \u201cP\u201d for passport). Data priority: chip &gt; MRZ &gt; VIZ Enum: ['P', 'PC', 'I', 'D', 'C', 'OTHER']\n  val surname: String? = null, // Combined passport holder\u2019s surname.\n  val name: String? = null, // Combined passport holder\u2019s given names.\n  val docNumber: String? = null, // Combined passport document number.\n  val checkDigit: String? = null, // Combined check digit for the document number.\n  val nationality: String? = null, // Combined nationality ISO code.\n  val birthDate: String? = null, // Combined date of birth in YY-MM-DD format.\n  val birthDateDigit: String? = null, // Combined check digit for the birth date.\n  val sex: String? = null, // Combined gender of the passport holder. Enum: ['M', 'F', 'X']\n  val expiryDate: String? = null, // Combined passport expiry date in YY-MM-DD format.\n  val expiryDateDigit: String? = null, // Combined check digit for the expiry date.\n  val optionalData: String? = null, // Combined additional optional data (e.g., personal identification number).\n  val optionalDataDigit: String? = null, // Combined check digit for the optional data.\n  val mrzType: String? = \"unknown\", // Combined format of the MRZ (e.g., \u201cID-3\u201d). Enum: ['ID-1', 'ID-2', 'ID-3']\n  val docImagePath: String = PhotoPath.DOCUMENT_IMAGE_PATH,\n  val holderImagePath: String = PhotoPath.PORTRAIT_PHOTO_PATH,\n): Parcelable\n</code></pre> <pre><code>data class VIZSection(\n  val docType: String? = null, // Document type in the VIZ. Enum: ['PC', 'ID', 'C', 'OTHER']\n  val issueState: String? = null, // Issuing country code.\n  val surname: String? = null, // Passport/ID card holder\u2019s surname as shown in the VIZ.\n  val name: String? = null, // Passport/ID card holder\u2019s given names as shown in the VIZ.\n  val sex: String? = null, // Gender of the passport holder. Enum: ['M', 'F', 'X'] Nullable: true\n  val docNumber: String? = null, // Passport/ID card document number.\n  val nationality: String? = null, // Nationality in native language.\n  val issueDate: String? = null, //Date when the passport/ID card was issued.\n  val personalNumber: String? = null, // Personal identification number.\n  val height: String? = null, // Height of the passport/ID card holder.\n  val expiryDate: String? = null, // Expiry date of the passport/ID card.\n  val docImagePath: String = PhotoPath.DOCUMENT_IMAGE_PATH,\n  val holderImagePath: String = PhotoPath.PORTRAIT_PHOTO_PATH,\n  val validations: VIZValidation = VIZValidation(), // Validation status indicating if the document is expired\n): Parcelable\n</code></pre> <pre><code>data class MRZSection(\n  val mrzString: String? = null, // Raw MRZ data string.\n  val docType: String? = null, // Document type from MRZ. Enum: ['P', 'I', 'A', 'V', 'C', 'OTHER']\n  val surname: String? = null, // Passport/ID card holder\u2019s surname from MRZ.\n  val name: String? = null, // Passport/ID card holder\u2019s given names from MRZ.\n  val docNumber: String? = null, // Passport/ID card document number from MRZ.\n  val checkDigit: String? = null, // Check digit for the document number from MRZ.\n  val nationality: String? = null, // Nationality code from MRZ.\n  val birthDate: String? = null, // Date of birth from MRZ in YY-MM-DD format.\n  val birthDateDigit: String? = null, // Check digit for the birth date from MRZ.\n  val sex: String? = null, // Gender from MRZ. Enum: ['M', 'F', 'X']\n  val expiryDate: String? = null, // Expiry date from MRZ in YY-MM-DD format.\n  val expiryDateDigit: String? = null, // Check digit for the expiry date from MRZ.\n  val optionalData: String? = null, // Optional data from MRZ.\n  val optionalDataDigit: String? = null, // Check digit for the optional data from MRZ.\n  val mrzType: String? = null, // Format of the MRZ. Enum: ['ID-1', 'ID-2', 'ID-3']\n  val validations: MRZValidation = MRZValidation(),\n): Parcelable\n</code></pre> <pre><code>data class RFIDSection(\n  val mrzString: String? = null, // Raw MRZ data string from RFID chip.\n  val docType: String? = null, // Document type from RFID chip. Enum: ['P', 'I', 'V', 'C']\n  val surname: String? = null, // Passport/ID card holder\u2019s surname from RFID chip.\n  val name: String? = null, // Passport/ID card holder\u2019s given names from RFID chip.\n  val docNumber: String? = null, // Passport/ID card document number from RFID chip.\n  val checkDigit: String? = null, // Check digit for the document number from RFID chip.\n  val nationality: String? = null, // Nationality code from RFID chip.\n  val birthDate: String? = null, // Date of birth from RFID chip in YY-MM-DD format.\n  val birthDateDigit: String? = null, // Check digit for the birth date from RFID chip.\n  val sex: String? = null, // Gender from RFID chip. Enum: ['M', 'F', 'X']\n  val expiryDate: String? = null, // Expiry date from RFID chip in YY-MM-DD format.\n  val expiryDateDigit: String? = null, // Check digit for the expiry date from RFID chip.\n  val optionalData: String? = null, // Optional data from RFID chip.\n  val optionalDataDigit: String? = null, // Check digit for the optional data from RFID chip.\n  val mrzType: String? = null, // Format of the MRZ from RFID chip. Enum: ['ID-1', 'ID-2', 'ID-3']\n  val holderImagePath: String = PhotoPath.PORTRAIT_PHOTO_PATH,\n  val validations: RFIDValidation = RFIDValidation(),\n): Parcelable\n</code></pre></p> <p>The validations on each class contains information about the field status:</p> <pre><code>data class VIZValidation(\n  val expired: Int = 2, // Enum: [0, 1, 2] Description: \u2022 0: Failed \u2022 1: Success \u2022 2: Unknown\n): Parcelable\n\ndata class MRZValidation(\n  val checkDigit: Int = 2, // Enum: [0, 1, 2] Description: \u2022 0: Failed \u2022 1: Success \u2022 2: Unknown\n  val format: Int = 2, // Enum: [0, 1, 2] Description: \u2022 0: Failed \u2022 1: Success \u2022 2: Unknown\n  val expired: Int = 2, // Enum: [0, 1, 2] Description: \u2022 0: Failed \u2022 1: Success \u2022 2: Unknown\n): Parcelable\n\ndata class RFIDValidation(\n  val checkDigit: Int = 2, // Enum: [0, 1, 2] Description: \u2022 0: Failed \u2022 1: Success \u2022 2: Unknown\n  val expired: Int = 2, // Enum: [0, 1, 2] Description: \u2022 0: Failed \u2022 1: Success \u2022 2: Unknown\n): Parcelable\n\n/**\n  * Enum: [0, 1, 2]  0: Failed  \u2022 1: Success  \u2022 2: Unknown\n  * Data sources(exception on mrzType):\n  * - When chip read: chip + MRZ\n  * - When chip not read: MRZ + VIZ\n  * - When only MRZ: MRZ\n*/\ndata class Validations(\n  val status: Int = 2, // Overall validation/comparison status of the document.\n  val chip: Int = 2, // Overall validation of the chip read operation.\n  val docType: Int = 2, // Overall validation/comparison status of document type.\n  val surname: Int = 2, // Overall validation/comparison status of surname.\n  val name: Int = 2, // Overall validation/comparison status of name.\n  val docNumber: Int = 2, // Overall validation/comparison status of document number.\n  val checkDigit: Int = 2, // Overall validation/comparison status of check digit.\n  val nationality: Int = 2, // Overall validation/comparison status of nationality.\n  val birthDate: Int = 2, // Overall validation/comparison status of birth date.\n  val birthDateDigit: Int = 2, // Overall validation/comparison status of birth date check digit.\n  val sex: Int = 2, // Overall validation/comparison status of sex.\n  val expiryDate: Int = 2, // Overall validation/comparison status of expiry date.\n  val expiryDateDigit: Int = 2, // Overall validation/comparison status of expiry date check digit.\n  val optionalData: Int = 2, // Overall validation/comparison status of optional data.\n  val optionalDataDigit: Int = 2, // Overall validation/comparison status of optional data check digit.\n  val mrzType: Int = 2, // Overall validation/comparison status of MRZ type. When chip read: chip + MRZ  \u2022 When only MRZ: MRZ\n  val checkDigitCalculation: Int = 2, // Overall check digit calculation validation/comparison.\n  val expired: Int = 2, // Overall expiry validation/comparison indicating if the document is expired.\n  val aa: Int = 2, // Active Authentication status.\n  val bac: Int = 2, // Basic Access Control status.\n  val ca: Int = 2, // Chip Authentication status.\n  val pa: Int = 2, // Passive Authentication status.\n  val pace: Int = 2, // Password Authenticated Connection Establishment status.\n  val ta: Int = 2, // Terminal Authentication status.\n): Parcelable\n</code></pre> <p><pre><code>public class IdDocument: Codable {\n    public enum ValidationChipPage: Int, Codable {\n        /// No chip present\n        case noChip = 0\n        /// Chip is located in the document data page\n        case chipOnDataPage = 1\n        /// Chip is located in the back page or inlay of the document\n        case chipOnBackPage = 2\n        /// Unknown chip location\n        case unknown = 3\n    }\n\n    public enum ValidationElectronicChip: Int, Codable {\n        /// Document is not electronic\n        case notElectronic = 0\n        /// Document is electronic\n        case electronic = 1\n        /// Unknown if document is electronic\n        case unknown = 2\n    }\n\n    // MARK: - Properties\n\n    public var info: InfoSection?\n    public var data: DataSection?\n    public var viz: VIZSection?\n    public var mrz: MRZSection?\n    public var rfid: RFIDSection?\n    public var validations: Validations?\n\n    // MARK: - Initialization\n\n    public init(\n        info: InfoSection? = nil,\n        data: DataSection? = nil,\n        viz: VIZSection? = nil,\n        mrz: MRZSection? = nil,\n        rfid: RFIDSection? = nil,\n        validations: Validations? = nil\n    ) \n}\n</code></pre> <pre><code>public class InfoSection: Codable {\n    public enum InfoTypeEnum: String, Codable {\n        /// Passport\n        case passport = \"P\"\n        /// ID card\n        case idCard = \"I\"\n        /// Driver's license\n        case driverLicense = \"D\"\n        /// Document C\n        case documentC = \"C\"\n    }\n\n    // MARK: - Properties\n\n    /// A unique identifier for the document.\n    public let id: Int?\n\n    /// Indicates the type and issuing country of the document\n    public let documentName: String?\n\n    /// The International Civil Aviation Organization code for the issuing country.\n    public let ICAOCode: String?\n\n    /// Document type (e.g., \"P\" for passport)\n    public let type: InfoTypeEnum?\n\n    /// Specifies if the document is electronic\n    public let isElectronic: IdDocument.ValidationElectronicChip?\n\n    /// Status of the chip read operation\n    public let chipPage: IdDocument.ValidationChipPage?\n\n    // MARK: - Initialization\n\n    public init(\n        id: Int? = nil,\n        documentName: String? = nil,\n        ICAOCode: String? = nil,\n        type: InfoTypeEnum? = nil,\n        isElectronic: IdDocument.ValidationElectronicChip? = nil,\n        chipPage: IdDocument.ValidationChipPage? = .unknown\n    ) \n}\n</code></pre></p> <p><pre><code>public class DataSection: Codable {\n    public enum DocTypeEnum: String, Codable {\n        /// Passport\n        case passport = \"P\"\n        /// Document PC\n        case documentPC = \"PC\"\n        /// ID card\n        case idCard = \"I\"\n        /// Driver's license\n        case driverLicense = \"D\"\n        /// Document C\n        case documentC = \"C\"\n        /// Other document type\n        case other = \"OTHER\"\n    }\n\n    // MARK: - Properties\n\n    /// Combined raw MRZ data string. Data priority: chip &gt; MRZ\n    public let mrzString: String?\n\n    /// Combined document type (e.g., \"P\" for passport). Data priority: chip &gt; MRZ &gt; VIZ\n    public let docType: DocTypeEnum?\n\n    /// Combined passport holder's surname. Data priority: chip &gt; MRZ &gt; VIZ\n    public let surname: String?\n\n    /// Combined passport holder's given names. Data priority: chip &gt; MRZ &gt; VIZ\n    public let name: String?\n\n    /// Combined passport document number. Data priority: chip &gt; MRZ &gt; VIZ\n    public let docNumber: String?\n\n    /// Combined check digit for the document number. Data priority: chip &gt; MRZ &gt; VIZ\n    public let checkDigit: String?\n\n    /// Combined nationality ISO code. Data priority: chip &gt; MRZ &gt; VIZ\n    public let nationality: String?\n\n    /// Combined date of birth in YY-MM-DD format. Data priority: chip &gt; MRZ &gt; VIZ\n    public let birthDate: String?\n\n    /// Combined check digit for the birth date. Data priority: chip &gt; MRZ &gt; VIZ\n    public let birthDateDigit: String?\n\n    /// Combined gender of the passport holder. Data priority: chip &gt; MRZ &gt; VIZ\n    public let sex: ValidationSex?\n\n    /// Combined passport expiry date in YY-MM-DD format. Data priority: chip &gt; MRZ &gt; VIZ\n    public let expiryDate: String?\n\n    /// Combined check digit for the expiry date. Data priority: chip &gt; MRZ &gt; VIZ\n    public let expiryDateDigit: String?\n\n    /// Combined additional optional data (e.g., personal identification number). Data priority: chip &gt; MRZ &gt; VIZ\n    public let optionalData: String?\n\n    /// Combined check digit for the optional data. Data priority: chip &gt; MRZ &gt; VIZ\n    public let optionalDataDigit: String?\n\n    /// Combined format of the MRZ (e.g., \"ID-3\"). Data priority: chip &gt; MRZ &gt; VIZ\n    public let mrzType: ValidatiomMrzType?\n\n    /// Base64-encoded string of the passport/ID card holder's photo. Data priority: chip &gt; MRZ &gt; VIZ\n    public var holderImage: Data?\n\n    /// Base64-encoded string of the passport/id card photo\n    public var docImage: Data?\n\n    // MARK: - Computed Properties\n\n    public var holderImageUIImage: UIImage? {\n        holderImage.flatMap { UIImage(data: $0) }\n    }\n\n    public var docImageUIImage: UIImage? {\n        docImage.flatMap { UIImage(data: $0) }\n    }\n\n    // MARK: - Initialization\n\n    public init(\n        mrzString: String? = nil,\n        docType: DocTypeEnum? = nil,\n        surname: String? = nil,\n        name: String? = nil,\n        docNumber: String?,\n        checkDigit: String? = nil,\n        nationality: String? = nil,\n        birthDate: String?,\n        birthDateDigit: String? = nil,\n        sex: ValidationSex? = nil,\n        expiryDate: String?,\n        expiryDateDigit: String? = nil,\n        optionalData: String? = nil,\n        optionalDataDigit: String? = nil,\n        mrzType: ValidatiomMrzType? = .unknown,\n        holderImage: UIImage? = nil,\n        docImage: UIImage? = nil\n    )\n}\n</code></pre> <pre><code>public class VIZSection: Codable {\n    public enum VizDocTypeEnum: String, Codable {\n        /// Document PC\n        case documentPC = \"PC\"\n        /// ID card\n        case idCard = \"ID\"\n        /// Document C\n        case documentC = \"C\"\n        /// Other document type\n        case other = \"OTHER\"\n    }\n\n    // MARK: - Properties\n\n    /// Document type in the VIZ\n    public let docType: VizDocTypeEnum?\n\n    /// Issuing country code\n    public let issueState: String?\n\n    /// Passport/ID card holder's surname as shown in the VIZ\n    public let surname: String?\n\n    /// Passport/ID card holder's given names as shown in the VIZ\n    public let name: String?\n\n    /// Gender of the passport holder\n    public let sex: ValidationSex?\n\n    /// Passport/ID card document number\n    public let docNumber: String?\n\n    /// Nationality in native language\n    public let nationality: String?\n\n    /// Date when the passport/ID card was issued\n    public let issueDate: String?\n\n    /// Personal identification number\n    public let personalNumber: String?\n\n    /// Height of the passport/ID card holder\n    public let height: String?\n\n    /// Expiry date of the passport/ID card\n    public let expiryDate: String?\n\n    /// VIZ validations\n    public let validations: VIZValidation?\n\n    /// Base64-encoded string of the passport/ID card holder's photo in the VIZ\n    public var holderImage: Data?\n\n    /// VIZ base64-encoded string of the passport/id card photo\n    public var docImage: Data?\n\n    // MARK: - Computed Properties\n\n    public var holderImageUIImage: UIImage? {\n        holderImage.flatMap { UIImage(data: $0) }\n    }\n\n    public var docImageUIImage: UIImage? {\n        docImage.flatMap { UIImage(data: $0) }\n    }\n\n    // MARK: - Initialization\n\n    public init(\n        docType: VizDocTypeEnum? = nil,\n        issueState: String? = nil,\n        surname: String? = nil,\n        name: String? = nil,\n        sex: ValidationSex? = nil,\n        docNumber: String?,\n        nationality: String? = nil,\n        issueDate: String? = nil,\n        personalNumber: String? = nil,\n        height: String? = nil,\n        expiryDate: String?,\n        holderImage: UIImage? = nil,\n        docImage: UIImage? = nil,\n        validations: VIZValidation? = VIZValidation()\n    )\n}\n\n// MARK: - VIZValidation\n\npublic class VIZValidation: Codable {\n    /// Validation check for expiration\n    public let expired: ValidationCheck?\n\n    public init(expired: ValidationCheck? = .unknown) \n}\n</code></pre> <pre><code>    public class MRZSection: Codable {\n    public enum MrzDocTypeEnum: String, Codable {\n        /// Passport\n        case passport = \"P\"\n        /// ID card\n        case idCard = \"I\"\n        /// Document A\n        case documentA = \"A\"\n        /// Visa\n        case visa = \"V\"\n        /// Document C\n        case documentC = \"C\"\n        /// Other document type\n        case other = \"OTHER\"\n    }\n\n    // MARK: - Properties\n\n    /// Raw MRZ data string\n    public let mrzString: String?\n\n    /// Document type from MRZ\n    public let docType: MrzDocTypeEnum?\n\n    /// Passport/ID card holder's surname from MRZ\n    public let surname: String?\n\n    /// Passport/ID card holder's given names from MRZ\n    public let name: String?\n\n    /// Passport/ID card document number from MRZ\n    public let docNumber: String?\n\n    /// Check digit for the document number from MRZ\n    public let checkDigit: String?\n\n    /// Nationality code from MRZ\n    public let nationality: String?\n\n    /// Date of birth from MRZ in YY-MM-DD format\n    public let birthDate: String?\n\n    /// Check digit for the birth date from MRZ\n    public let birthDateDigit: String?\n\n    /// Gender from MRZ\n    public let sex: ValidationSex?\n\n    /// Expiry date from MRZ in YY-MM-DD format\n    public let expiryDate: String?\n\n    /// Check digit for the expiry date from MRZ\n    public let expiryDateDigit: String?\n\n    /// Optional data from MRZ\n    public let optionalData: String?\n\n    /// Check digit for the optional data from MRZ\n    public let optionalDataDigit: String?\n\n    /// Format of the MRZ\n    public let mrzType: ValidatiomMrzType?\n\n    /// MRZ validations\n    public let validations: MRZValidation?\n\n    // MARK: - Initialization\n\n    public init(\n        mrzString: String? = nil,\n        docType: MrzDocTypeEnum? = nil,\n        surname: String? = nil,\n        name: String? = nil,\n        docNumber: String?,\n        checkDigit: String? = nil,\n        nationality: String? = nil,\n        birthDate: String?,\n        birthDateDigit: String? = nil,\n        sex: ValidationSex? = nil,\n        expiryDate: String?,\n        expiryDateDigit: String? = nil,\n        optionalData: String? = nil,\n        optionalDataDigit: String? = nil,\n        mrzType: ValidatiomMrzType? = .unknown,\n        validations: MRZValidation? = MRZValidation()\n    )\n}\n\n// MARK: - MRZValidation\n\npublic class MRZValidation: Codable {\n    /// Check digit validation status\n    public let checkDigit: ValidationCheck?\n\n    /// Format validation status\n    public let format: ValidationCheck?\n\n    /// Expiry validation status\n    public let expired: ValidationCheck?\n\n    public init(\n        checkDigit: ValidationCheck? = .unknown,\n        format: ValidationCheck? = .unknown,\n        expired: ValidationCheck? = .unknown\n    )\n}\n</code></pre> <pre><code>public class RFIDSection: Codable {\n    public enum RfidDocTypeEnum: String, Codable {\n        /// Passport\n        case passport = \"P\"\n        /// ID card\n        case idCard = \"I\"\n        /// Visa\n        case visa = \"V\"\n        /// Document C\n        case documentC = \"C\"\n        /// Other document type\n        case other = \"OTHER\"\n    }\n\n    // MARK: - Properties\n\n    /// Raw MRZ data string from RFID chip\n    public let mrzString: String?\n\n    /// Document type from RFID chip\n    public let docType: RfidDocTypeEnum?\n\n    /// Passport/ID card holder's surname from RFID chip\n    public let surname: String?\n\n    /// Passport/ID card holder's given names from RFID chip\n    public let name: String?\n\n    /// Passport/ID card document number from RFID chip\n    public let docNumber: String?\n\n    /// Check digit for the document number from RFID chip\n    public let checkDigit: String?\n\n    /// Nationality code from RFID chip\n    public let nationality: String?\n\n    /// Date of birth from RFID chip in YY-MM-DD format\n    public let birthDate: String?\n\n    /// Check digit for the birth date from RFID chip\n    public let birthDateDigit: String?\n\n    /// Gender from RFID chip\n    public let sex: ValidationSex?\n\n    /// Expiry date from RFID chip in YY-MM-DD format\n    public let expiryDate: String?\n\n    /// Check digit for the expiry date from RFID chip\n    public let expiryDateDigit: String?\n\n    /// Optional data from RFID chip\n    public let optionalData: String?\n\n    /// Check digit for the optional data from RFID chip\n    public let optionalDataDigit: String?\n\n    /// Format of the MRZ from RFID chip\n    public let mrzType: ValidatiomMrzType?\n\n    /// Base64-encoded string of the passport/ID card holder's photo from RFID chip\n    public var holderImage: Data?\n\n    /// RFID validations\n    public var validations: RFIDValidation?\n\n    // MARK: - Computed Properties\n\n    public var holderImageUIImage: UIImage? {\n        holderImage.flatMap { UIImage(data: $0) }\n    }\n\n    // MARK: - Initialization\n\n    public init(\n        mrzString: String? = nil,\n        docType: RfidDocTypeEnum? = nil,\n        surname: String? = nil,\n        name: String? = nil,\n        docNumber: String?,\n        checkDigit: String? = nil,\n        nationality: String? = nil,\n        birthDate: String?,\n        birthDateDigit: String? = nil,\n        sex: ValidationSex? = nil,\n        expiryDate: String?,\n        expiryDateDigit: String? = nil,\n        optionalData: String? = nil,\n        optionalDataDigit: String? = nil,\n        mrzType: ValidatiomMrzType? = .unknown,\n        holderImage: UIImage? = nil,\n        validations: RFIDValidation? = RFIDValidation()\n    )\n}\n\n// MARK: - RFIDValidation\n\npublic class RFIDValidation: Codable {\n    /// Check digit validation status\n    public let checkDigit: ValidationCheck?\n\n    /// Expiry validation status\n    public let expired: ValidationCheck?\n\n    public init(\n        checkDigit: ValidationCheck? = .unknown,\n        expired: ValidationCheck? = .unknown\n    )\n}\n</code></pre> <pre><code>public class Validations: Codable {\n    /// Overall validation/comparison status of the document\n    public let status: ValidationCheck?\n\n    /// Overall validation of the chip read operation\n    public let chip: ValidationCheck?\n\n    /// Overall validation/comparison status of document type\n    public let docType: ValidationCheck?\n\n    /// Overall validation/comparison status of surname\n    public let surname: ValidationCheck?\n\n    /// Overall validation/comparison status of name\n    public let name: ValidationCheck?\n\n    /// Overall validation/comparison status of document number\n    public let docNumber: ValidationCheck?\n\n    /// Overall validation/comparison status of check digit\n    public let checkDigit: ValidationCheck?\n\n    /// Overall validation/comparison status of nationality\n    public let nationality: ValidationCheck?\n\n    /// Overall validation/comparison status of birth date\n    public let birthDate: ValidationCheck?\n\n    /// Overall validation/comparison status of birth date check digit\n    public let birthDateDigit: ValidationCheck?\n\n    /// Overall validation/comparison status of sex\n    public let sex: ValidationCheck?\n\n    /// Overall validation/comparison status of expiry date\n    public let expiryDate: ValidationCheck?\n\n    /// Overall validation/comparison status of expiry date check digit\n    public let expiryDateDigit: ValidationCheck?\n\n    /// Overall validation/comparison status of optional data\n    public let optionalData: ValidationCheck?\n\n    /// Overall validation/comparison status of optional data check digit\n    public let optionalDataDigit: ValidationCheck?\n\n    /// Overall validation/comparison status of MRZ type\n    public let mrzType: ValidationCheck?\n\n    /// Overall check digit calculation validation/comparison\n    public let checkDigitCalculation: ValidationCheck?\n\n    /// Overall expiry validation/comparison indicating if the document is expired\n    public let expired: ValidationCheck?\n\n    /// Active Authentication status\n    public let AA: ValidationCheck?\n\n    /// Basic Access Control status\n    public let BAC: ValidationCheck?\n\n    /// Chip Authentication status\n    public let CA: ValidationCheck?\n\n    /// Passive Authentication status\n    public let PA: ValidationCheck?\n\n    /// Password Authenticated Connection Establishment status\n    public let PACE: ValidationCheck?\n\n    /// Terminal Authentication status\n    public let TA: ValidationCheck?\n\n    public init(\n        status: ValidationCheck? = .unknown,\n        chip: ValidationCheck? = .unknown,\n        docType: ValidationCheck? = .unknown,\n        surname: ValidationCheck? = .unknown,\n        name: ValidationCheck? = .unknown,\n        docNumber: ValidationCheck? = .unknown,\n        checkDigit: ValidationCheck? = .unknown,\n        nationality: ValidationCheck? = .unknown,\n        birthDate: ValidationCheck? = .unknown,\n        birthDateDigit: ValidationCheck? = .unknown,\n        sex: ValidationCheck? = .unknown,\n        expiryDate: ValidationCheck? = .unknown,\n        expiryDateDigit: ValidationCheck? = .unknown,\n        optionalData: ValidationCheck? = .unknown,\n        optionalDataDigit: ValidationCheck? = .unknown,\n        mrzType: ValidationCheck? = .unknown,\n        checkDigitCalculation: ValidationCheck? = .unknown,\n        expired: ValidationCheck? = .unknown,\n        AA: ValidationCheck? = .unknown,\n        BAC: ValidationCheck? = .unknown,\n        CA: ValidationCheck? = .unknown,\n        PA: ValidationCheck? = .unknown,\n        PACE: ValidationCheck? = .unknown,\n        TA: ValidationCheck? = .unknown\n    )\n}\n</code></pre> The ValidationCheck, ValidationSex and ValidatiomMrzType are enums that have the following possibilities:</p> <pre><code>public enum ValidationCheck: Int, Codable {\n    case failed = 0\n    case success = 1\n    case unknown = 2\n}\n\npublic enum ValidationSex: String, Codable {\n    case male = \"M\"\n    case female = \"F\"\n    case other = \"X\"\n}\n\npublic enum ValidatiomMrzType: String, Codable {\n    case id1 = \"ID-1\"\n    case id2 = \"ID-2\"\n    case id3 = \"ID-3\"\n    case unknown = \"Unknown\"\n}\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_Index.html#documentreadercustomviews","title":"DocumentReaderCustomViews","text":"<p>The SDK provides default UI solutions for the document reader feature flow, as shown in the following images: </p> <p>The use of the rfid related layouts depends on the rfidRead flag in the DocumentReaderParameters.</p> <p>You can also apply your app\u2019s colors and fonts to these layout solutions, to keep your brand\u2019s image consistent. Check Customization tab to learn more about branding of each view.</p> AndroidiOS <p><pre><code>class DocumentReaderCustomViews(\n    val loadingView: Class&lt;out ICustomDocumentReader.LoadingView&gt;? = null,\n    val rfidInstructionsView: Class&lt;out ICustomDocumentReader.RfidInstructionsView&gt;? = null,\n    val rfidSearchView: Class&lt;out ICustomDocumentReader.RfidSearchView&gt;? = null,\n    val rfidProcessView: Class&lt;out ICustomDocumentReader.RfidProcessView&gt;? = null,\n)\n</code></pre> You can use your own custom views in the document reader functionality. Your view must implement the SDK view interfaces. For example, if you want to add a custom loading view, your view class must implement the ICustomDocumentReader.LoadingView interface.</p> <pre><code>public class EnrolmentViewRegister {\n    ...\n    // MARK: - Document Reader\n    public func registerDocumentReaderRFIDInstructionsView(_ viewType: DocumentReaderRFIDInstructionsViewType)\n    public func registerDocumentReaderLoadingView(_ viewType: DocumentReaderLoadingViewType)\n    ...\n}    \n</code></pre> <p>Our SDK also allows you to pass your own custom views. The only requirement is that your view must implement the SDK view protocols. For example, if you want to add a custom loading view, your view class must implement the DocumentReaderLoadingViewType.</p> <p>In the customization tab you will also find examples to create your own custom views.</p>"},{"location":"Features/DocumentReader/DocumentReader_LoadingView.html","title":"Loading View","text":"<p>The first view of the document reader flow is the loading view, it appears when the feature is initializing. In this step, if the regula database is not yet downloaded or it's outdated, the download will begin automatically.</p> <p></p> <p>It contains a title(1), a message(2), an animation(3) and a background that can be customized. </p>"},{"location":"Features/DocumentReader/DocumentReader_LoadingView.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/DocumentReader/DocumentReader_LoadingView.html#text-resources","title":"Text resources","text":"AndroidiOS <p>You can add your own texts and localization by overriding the following string resources: <pre><code>&lt;string name=\"document_reader_loading_overlay_title_sdk_enrolment\"&gt;Loading Document Reader&lt;/string&gt;\n&lt;string name=\"document_reader_initializing_overlay_message_sdk_enrolment\"&gt;This may take a moment&lt;/string&gt;\n&lt;!-- In case the regula database needs to be downloaded we show the progress in text --&gt;\n&lt;string name=\"document_read_reader_download_progress_sdk_enrolment\"&gt;Downloading resources: %d%%&lt;/string&gt;\n&lt;!-- When the feature is ready to start we display this message in the subtitle --&gt;\n&lt;string name=\"document_reader_loading_overlay_subtitle_sdk_enrolment\"&gt;We\\'ll first take a picture of your document&lt;/string&gt;\n</code></pre></p> <p>The best way to override strings is by adding your key through the Theme class</p> <pre><code>Theme.shared.strings.documentReader.initialization\nTheme.shared.strings.documentReader.initializationSubtitle\nTheme.shared.strings.documentReaderdownloadProgress\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_LoadingView.html#colors","title":"Colors","text":"AndroidiOS <p>You can change the text colors by overriding the following color resource (It affects all texts): <pre><code>&lt;color name=\"colorFaceCaptureTxtDarkSdkEnrolment\"&gt;#1A1C1E&lt;/color&gt;\n</code></pre></p> <p>You can change the background color by overriding the following color resource: <pre><code>&lt;color name=\"colorOverlayFeedbackBgSdkEnrolment\"&gt;#EAEEF6&lt;/color&gt;\n</code></pre></p> <p>You can change the text colors by overriding the following color in Theme class (It affects all Loading Screens):</p> <pre><code>Theme.shared.colors.checkPermission.title\nTheme.shared.colors.checkPermission.subtitle\n</code></pre> <p>You can change the background color by overriding the following color in Theme class(It affects all Loading Screens):</p> <pre><code>Theme.shared.colors.checkPermission.background\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_LoadingView.html#styles","title":"Styles","text":"AndroidiOS <p>You can extend the styles we use and override any properties (textColor, textSize, fontFamily, etc...) you want. <pre><code>&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Title.Centered\"&gt;\n&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Subtitle.Centered\"&gt;\n</code></pre> Note: It will affect every component that uses the same style.</p> <p>You can change the font through the theme class (this will affect all text in the app): <pre><code>Theme.shared.fonts.bold\nTheme.shared.fonts.regular\n</code></pre></p>"},{"location":"Features/DocumentReader/DocumentReader_LoadingView.html#animation","title":"Animation","text":"AndroidiOS <p>You can change the loading animation by adding a raw json animation file with this name: <pre><code>loading_document_reader_sdk_enrolment.json\n</code></pre></p> <p>You can change the loading animation by adding a raw json animation file and overriding the following animation name in Theme class <pre><code>Theme.shared.animations.documentReader.loadingDocuments\n</code></pre></p>"},{"location":"Features/DocumentReader/DocumentReader_LoadingView.html#use-your-own-layouts","title":"Use your own layouts","text":"AndroidiOS <p>To use your own loading screen for document reader feature, you need to implement the MobileID SDK Interface for that view.</p> <p>In this case: ICustomDocumentReader.LoadingView <pre><code>interface LoadingView {\n    fun onPreFeatureLoading(message: String)\n    fun onPostFeatureLoading()\n    fun onDownloadProgressChanged(progress: Int)\n    fun hideLoading()\n}\n</code></pre> In this screen, the loading time can deppend on the status of the database and wether it's the first feature to be called or not. Due to this, we have 4 methods were you can update the messages being displayed in the loading screen, or you can opt to ignore those functions.</p> <p>onPreFeatureLoading is called multiple times, with different messages that display what is happening while initializing the feature. onPostFeatureLoading is called when the transaction is being registered. onDownloadProgressChanged is called when the database download is in progress so you can share the progress with the user. hideLoading is called when the view is dismissed.</p> <p>For example create a class DocumentReaderLoadingCustomView, create a layout file and bind it.</p> <pre><code>class DocumentReaderLoadingCustomView(\ncontext: Context\n) : ConstraintLayout(context), ICustomDocumentReader.LoadingView {\nprivate var binding: ViewDocumentReaderLoadingBinding\n\n    init {\n        binding = ViewDocumentReaderLoadingBinding.inflate(LayoutInflater.from(context), this)\n    }\n\n    override fun onPreFeatureLoading(message: String) {\n        binding.documentReadLoadingMessage.text = message\n    }\n\n    override fun onPostFeatureLoading() {\n        binding.documentReadLoadingTitle.text = \"Communicating\"\n        binding.documentReadLoadingMessage.text = \"\"\n    }\n\n    override fun onDownloadProgressChanged(progress: Int) {\n        binding.documentReadLoadingMessage.text = \"Progress: $progress%\"\n    }\n\n    override fun hideLoading() {\n        // Do nothing\n    }\n}\n</code></pre> <p>You need to register a class of type DocumentReaderLoadingViewType through the following function of EnrolmentViewRegister <pre><code>public func registerDocumentReaderLoadingView(_ viewType: DocumentReaderLoadingViewType)\n</code></pre></p> <p>The DocumentReaderLoadingViewType class needs to respect the following protocols:</p> <pre><code>public protocol FeatureLoadingViewInterface {\n    func onPreFeatureLoading()\n    func onPostFeatureLoading()\n    func hideLoading()\n}\n\npublic typealias FeatureLoadingViewType = FeatureLoadingView.Type\npublic typealias FeatureLoadingView = UIView &amp; FeatureLoadingViewInterface\n\npublic protocol DocumentReaderLoadingViewInterface: FeatureLoadingView {\n    func onDownloadProgressChanged(progress: Int)\n    func onPreparingFeature()\n}\n\npublic typealias DocumentReaderLoadingViewType = DocumentReaderLoadingView.Type\npublic typealias DocumentReaderLoadingView = UIView &amp; DocumentReaderLoadingViewInterface\n</code></pre> <p>Example: <pre><code>class LoadingView: DocumentReaderLoadingView {\n\n    // MARK: - Initialization\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        //add any UI customization you need\n    }\n\n    // MARK: - Functions\n\n    func onDownloadProgressChanged(progress: Int) {\n        //add any UI customization you need\n    }\n\n    func onPreparingFeature() {\n        //add any UI customization you need\n    }\n\n    func onPreFeatureLoading() {\n        //add any UI customization you need\n    }\n\n    func onPostFeatureLoading() {\n        //add any UI customization you need\n    }   \n\n    func hideLoading() {\n        //You can stop animations or other activities that consumes resources \n    }\n}\n</code></pre></p>"},{"location":"Features/DocumentReader/DocumentReader_PreviewView.html","title":"Preview View","text":"<p>From version 8 onwards, the preview management changed in the SDK to make it easier to integrate.</p> <p>To improve flexibility in the preview screen, the optional preview screen has been removed.</p> <p>To add a preview feature to your app you can follow the example from our sample app, where we provide an example with the same user interface.</p> AndroidiOS <p>Example can be found here: DocumentReaderPreview</p> <p>Example can be found here: Sample Project</p>"},{"location":"Features/DocumentReader/DocumentReader_RFIDReadView.html","title":"RFID Instructions View","text":"<p>The third view of the document reader flow is the RFID Read View, this screen only appears if it is an e-Document and the variable readRFID from ReadDocumentParameters is active. This screen allows the user to prepare for the chip reading or skip this feature.</p> <p></p> <p>It contains a title(1), a message(2), an image(3), a read button(4), a skip button(5) and a background that can be customized. </p>"},{"location":"Features/DocumentReader/DocumentReader_RFIDReadView.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/DocumentReader/DocumentReader_RFIDReadView.html#text-resources","title":"Text resources","text":"AndroidiOS <p>You can add your own texts and localization by overriding the following string resources: <pre><code>&lt;string name=\"rfid_instructions_read_title_sdk_enrolment\"&gt;Scanning complete;\\nlet\\'s scan your document chip.&lt;/string&gt;\n&lt;string name=\"rfid_instructions_read_subtitle_sdk_enrolment\"&gt;Your phone is able to detect and read the chip in your document. By doing this, all information can be verified right away.&lt;/string&gt;\n&lt;string name=\"rfid_instructions_read_sdk_enrolment\"&gt;Read chip&lt;/string&gt;\n&lt;string name=\"rfid_instructions_skip_read_sdk_enrolment\"&gt;Skip chip read&lt;/string&gt;\n</code></pre></p> <p>The best way to override strings is by adding your key through the Theme class</p> <pre><code>Theme.shared.strings.rfid.rfidReadTitle\nTheme.shared.strings.rfid.rfidReadSubtitle\nTheme.shared.strings.buttons.readChip\nTheme.shared.strings.buttons.skipChipRead\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_RFIDReadView.html#colors","title":"Colors","text":"AndroidiOS <p>You can change the text colors by overriding the following color resource (It affects all texts): <pre><code>&lt;color name=\"colorFaceCaptureTxtDarkSdkEnrolment\"&gt;#1A1C1E&lt;/color&gt;\n</code></pre></p> <p>You can change the background color by overriding the following color resource: <pre><code>&lt;color name=\"colorDocumentReadRFIDBgSdkEnrolment\"&gt;#EAEEF6&lt;/color&gt;\n</code></pre></p> <p>You can change the text colors by overriding the following color in Theme class: <pre><code>Theme.shared.colors.rfidData.title\nTheme.shared.colors.rfidData.subtitle\n</code></pre></p> <p>You can change the background color by overriding the following color in Theme class: <pre><code>Theme.shared.colors.rfidData.background\n</code></pre></p> <p>You can change the color of the read button (this affects all primary style buttons) <pre><code>Theme.shared.colors.button.primaryBackground\nTheme.shared.colors.button.primaryTitle\n</code></pre></p> <p>You can change the color of the skip button (this affects all secondary style buttons) <pre><code>Theme.shared.colors.button.secondaryBackground\nTheme.shared.colors.button.secondaryTitle\n</code></pre></p>"},{"location":"Features/DocumentReader/DocumentReader_RFIDReadView.html#styles","title":"Styles","text":"AndroidiOS <p>You can extend the styles we use and override any properties (textColor, textSize, fontFamily, etc...) you want. <pre><code>&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Title.Centered\"&gt;\n&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Subtitle.Centered\"&gt;\n</code></pre> Note: It will affect every component that uses the same style.</p> <p>You can change the font through the theme class (this will affect all text in the app): <pre><code>Theme.shared.fonts.bold\nTheme.shared.fonts.regular\n</code></pre></p>"},{"location":"Features/DocumentReader/DocumentReader_RFIDReadView.html#image","title":"Image","text":"AndroidiOS <p>You can change the image by adding a drawable with this name: <pre><code>ic_read_chip_instructions.xml\n</code></pre> The image we are using is 208x208dp.</p> <p>You can change the image by adding a asset file and overriding the following image name in Theme class <pre><code>Theme.shared.images.documentReader.rfiDescription\n</code></pre></p>"},{"location":"Features/DocumentReader/DocumentReader_RFIDReadView.html#use-your-own-layouts","title":"Use your own layouts","text":"AndroidiOS <p>To use your own custom screens for document reader feature, you need to implement the MobileID SDK Interface for that view.</p> <p>In this case: ICustomDocumentReader.RfidInstructionsView <pre><code>interface RfidInstructionsView{\n    fun getReadChipButton(): View?\n    fun getSkipButton(): View?\n    fun hideInstructions()\n}\n</code></pre></p> <ul> <li>getReadChipButton method must return a Button to start the rfid reading, when clicked it will also start the timeout.</li> <li>getSkipButton can return either null or a button/image to skip the rfid reading.</li> <li>hideInstructions is called when the view is dismissed.</li> </ul> <p>For example create a class RfidTutorialCustomView, create a layout file and bind it.</p> <pre><code>class RfidTutorialCustomView(\ncontext: Context\n) : ConstraintLayout(context), ICustomDocumentReader.RfidInstructionsView {\nprivate var binding: ViewRfidTutorialBinding // Requires view binding enabled\n// private var view: View\n\n    init {\n        binding = ViewRfidTutorialBinding.inflate(LayoutInflater.from(context), this)\n        // You can also use other inflate method like this:\n        // view = inflate(context, R.layout.view_rfid_tutorial, this)\n    }\n    override fun getReadChipButton() = binding.btnReadChip\n    // override fun getReadChipButton(): View = view.findViewById(R.id.btn_read_chip)\n\n    override fun getSkipButton() = binding.btnSkip\n\n    override fun hideInstructions() {\n        // Do nothing\n    }\n}\n</code></pre> <p>You need to register a class of type DocumentReaderRFIDInstructionsViewType through the following function of EnrolmentViewRegister <pre><code>public func registerDocumentReaderRFIDInstructionsView(_ viewType: DocumentReaderRFIDInstructionsViewType)\n</code></pre></p> <p>The DocumentReaderRFIDInstructionsViewType class needs to respect the following protocols:</p> <pre><code>public protocol DocumentReaderRFIDInstructionsViewInterface {\n    var delegate: DocumentReaderRFIDInstructionsViewDelegate? { get set }\n    func hideInstructions()\n}\n\npublic protocol DocumentReaderRFIDInstructionsViewDelegate: AnyObject {\n    func didPressReadChipButton()\n    func didPressSkipButton()\n}\n\npublic typealias DocumentReaderRFIDInstructionsViewType = DocumentReaderRFIDInstructionsView.Type\npublic typealias DocumentReaderRFIDInstructionsView = UIView &amp; DocumentReaderRFIDInstructionsViewInterface\n</code></pre> <p>Example: <pre><code>class RFIDReadView: DocumentReaderRFIDInstructionsView {\n\n    weak var delegate: DocumentReaderRFIDInstructionsViewDelegate?\n\n// MARK: - Initialization\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        //add any UI customization you need\n    }\n\n// MARK: - Actions\n\n    @objc private func readChipButtonTapped(button: UIButton) {\n        delegate?.didPressReadChipButton()\n    }\n\n    @objc private func skipButtonTapped(button: UIButton) {\n        delegate?. didPressSkipButton()\n    }\n\n// MARK: - Functions\n\n    func hideInstructions() {\n        //You can stop animations or other activities that consumes resources \n    }\n}\n</code></pre></p>"},{"location":"Features/DocumentReader/DocumentReader_ReadChipView_Android.html","title":"Read Chip View","text":"<p>It contains a title(1), a message(2), an animation(3), a loading spinner(4), a loading message(5) and a background that can be customized. </p>"},{"location":"Features/DocumentReader/DocumentReader_ReadChipView_Android.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/DocumentReader/DocumentReader_ReadChipView_Android.html#text-resources","title":"Text resources","text":"<p>You can add your own texts and localization by overriding the following string resources:</p> <pre><code>&lt;resources&gt;\n    &lt;string name=\"nfc_tag_detected_title_loading_sdk_enrolment\"&gt;Keep your phone still&lt;/string&gt;\n    &lt;string name=\"nfc_tag_detected_subtitle_loading_sdk_enrolment\"&gt;Your phone identified the chip and it\u2019s reading it.\\nPlease, don\u2019t move your phone.&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_ReadChipView_Android.html#colors","title":"Colors","text":"<p>You can change the colors of text elements, the background and/or the spinner in the bottom area  that shows the progress of the RFID reading by overriding the following color resource (It affects all texts):</p> <pre><code>&lt;resources&gt;\n    &lt;!-- Change the text color --&gt;\n    &lt;color name=\"colorFaceCaptureTxtDarkSdkEnrolment\"&gt;#1A1C1E&lt;/color&gt;\n    &lt;!-- Change the background color --&gt;\n    &lt;color name=\"colorOverlayFeedbackBgSdkEnrolment\"&gt;#EAEEF6&lt;/color&gt;\n    &lt;!-- Change the spinner colors --&gt;\n    &lt;color name=\"colorProgressBarSecondaryProgressSdkEnrolment\"&gt;#CFD8DC&lt;/color&gt;\n    &lt;color name=\"colorProgressBarPrimaryProgressSdkEnrolment\"&gt;#0000FF&lt;/color&gt;\n&lt;/resources&gt;\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_ReadChipView_Android.html#styles","title":"Styles","text":"<p>You can extend the styles we use and override any properties (textColor, textSize, fontFamily, etc...) you want. <pre><code>&lt;resources&gt;\n    &lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Title.Centered\"&gt;&lt;/style&gt;\n    &lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Subtitle.Centered\"&gt;&lt;/style&gt;\n&lt;/resources&gt;\n</code></pre> Note: It will affect every component that uses the same style.</p>"},{"location":"Features/DocumentReader/DocumentReader_ReadChipView_Android.html#animation","title":"Animation","text":"<p>You can change the animation by adding a raw json animation file with this name:</p> <ul> <li>chip_read_finding_sdk_enrolment.json for the large animation</li> </ul> <p>You can change the spinner  animation by adding a drawable file with this name:</p> <ul> <li>pb_progress_bar_style.xml</li> </ul>"},{"location":"Features/DocumentReader/DocumentReader_ReadChipView_Android.html#use-your-own-layouts","title":"Use your own layouts","text":"<p>To use your own custom screens for document reader feature, you need to implement the MobileID SDK Interface for that view. In this case: ICustomDocumentReader.RfidProcessView <pre><code>interface RfidProcessView {\n    fun updateRFIdStatus(text: String, progress: Int)\n    fun hideProcess()\n}\n</code></pre></p> <p>updateRfidStatus is called when the progress of the chip reading changes. </p> <p>Since this stage takes multiple different readings: - The text variable contains information sent by Regula to identify what's being read at the moment.  - The progress variable is a 0-100 variable that display the percentage read of that component.</p> <p>For example create a class RfidProcessCustomView, create a layout file and bind it.</p> <pre><code>class RfidProcessCustomView(\n    context: Context\n) : ConstraintLayout(context), ICustomDocumentReader.RfidProcessView {\n    private var binding: ViewRfidProcessBinding\n\n    init {\n        binding = ViewRfidProcessBinding.inflate(LayoutInflater.from(context), this)\n    }\n\n    override fun updateRFIdStatus(text: String, progress: Int) {\n        binding.tvRfidProcessMessage.text = \"$text| $progress%\"\n    }\n\n    override fun hideProcess() {\n        // Do nothing\n    }\n}\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_ReadChipView_iOS.html","title":"Read Chip View","text":"<p>This screen is exclusive to iOS. It is Apple's native implementation of RFID chip reading and cannot be customized in any way.</p> <p></p>"},{"location":"Features/DocumentReader/DocumentReader_RegulaDB.html","title":"Database download methods","text":"<p>The document reader requires a document database of templates.</p>"},{"location":"Features/DocumentReader/DocumentReader_RegulaDB.html#runtime-download","title":"Runtime download","text":"<p>Usually this file is downloaded in runtime and since it's a large file can take sometime to finish, depending on the user internet. This download will happen in the first run and everytime the database is outdated. </p> <p>There are two ways to download this file: - By default, the download will happen in the beginning of the document reader - You can trigger this download at anytime in your app by calling the enrolment facade method:</p> AndroidiOS <pre><code>enrolment.startDatabaseUpdate(object: RegulaDatabaseListener {\n  override fun onDownloadProgressChanged(progress: Int) {\n    Log.i(\"RegulaDBUpdate\", \"progress = {$progress}\")\n  }\n\n  override fun onReady() {\n    Log.i(\"RegulaDBUpdate\", \"Regula Database updated\")\n  }\n\n  override fun unableToPrepareDatabase(error: String?) {\n    Log.i(\"RegulaDBUpdate\", \"error = $error\")\n  }\n})\n</code></pre> <pre><code>func startUpdateDatabase(progressHandler: ((Progress) -&gt; Void)?, completion: @escaping (Result&lt;Void, DocumentReaderError&gt;) -&gt; Void)\n</code></pre> <p>With this method you can start the download at anytime decreasing the loading time of the document reader.</p> AndroidiOS <p>If you need to stop listening for the download progress, you can remove the callback at anytime by calling the method:</p> <pre><code>override fun removeDatabaseUpdateListener() {\n    enrolment.removeDatabaseUpdateListener(yourListener)\n}\n</code></pre> <p>At this time it is not possible to remove handlers during the process. They will be automatically removed when the download is completed successfully or in error.</p>"},{"location":"Features/DocumentReader/DocumentReader_RegulaDB.html#bundled-option","title":"Bundled option","text":"<p>It's also possible to pre-bundle the database into your own application in order to speed document reader init time. Keep in mind that the final apk size will increase significantly using this method.</p> <p>In order to bundle the database into your application you will need to:</p> <ol> <li>Download the appropriate database:<ul> <li>change &lt;your_db&gt; for the appropriate value (example: Full, Passports)</li> <li>check the compatible version (currently 6.1)</li> <li>use the 'url' link to download the database</li> </ul> </li> <li>Depending on your platform, complete the remaining step:</li> </ol> AndroidiOS <p>Add the downloaded database file to the app/src/main/assets/Regula folder of the project.</p> <p>Add the downloaded database file to the desired project's target.</p> <p>Everytime there's a new version available, Mobile ID SDK will still download the newest version and replace it,  so this method requires to manually update the source often in order to be effective.</p>"},{"location":"Features/DocumentReader/DocumentReader_ScanView.html","title":"Scan View","text":"<p>The second view of the document reader flow is the scan view, it's the camera screen that detects the document and reads it's data through OCR method. This screen belongs to Regula and it does not allow us to change, only some small customization is possible.</p> <p></p> <p>It contains a title(1), a message(2), a frame(3) and a cancel button (4) that can be customized.</p>"},{"location":"Features/DocumentReader/DocumentReader_ScanView.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/DocumentReader/DocumentReader_ScanView.html#text-resources","title":"Text resources","text":"<p>This text is dynamic and has been translated into several languages</p> <p>info \"Supported languages:\"</p> <pre><code>- Arabic (ar)\n- Bangla (bn)\n- Czech (cs)\n- Danish (da)\n- German (de)\n- Greek (el)\n- English (en)\n- Spanish (es)\n- Finnish (fi)\n- French (fr)\n- Hebrew (he)\n- Hindi (hi)\n- Croatian (hr)\n- Hungarian (hu)\n- Indonesian (id)\n- Italian (it)\n- Japanese (ja)\n- Korean (ko)\n- Malay (ms)\n- Norwegian (nb)\n- Dutch (nl)\n- Polish (pl)\n- Portuguese (pt)\n- Romanian (ro)\n- Russian (ru)\n- Slovak (sk)\n- Swedish (sv)\n- Thai (th)\n- Turkish (tr)\n- Ukrainian (uk)\n- Vietnamese (vi)\n- Chinese Simplified (zh-Hans)\n- Chinese Traditional (zh-Hant)\n</code></pre> <p>If you need additional localization support that is not on this list, then you need to follow this documentation steps: Regula localization support</p>"},{"location":"Features/DocumentReader/DocumentReader_ScanView.html#colors","title":"Colors","text":"AndroidiOS <p>This is not customizable in Android yet</p> <p>You can change the frame color by overriding the following color in Theme class (It other screens in the app):</p> <pre><code>// Default state\nTheme.shared.colors.common.black\n// Valid state\nTheme.shared.colors.faceCapture.stateValid\n</code></pre>"},{"location":"Features/DocumentReader/DocumentReader_ScanView.html#styles","title":"Styles","text":"AndroidiOS <p>This is not customizable in Android yet</p> <p>You can change the font through the theme class (this will affect all text in the app):</p> <pre><code>Theme.shared.fonts.bold\nTheme.shared.fonts.regular\n</code></pre>"},{"location":"Features/FaceCapture/FaceCapture_HandleErrors.html","title":"Handle Errors","text":"<p>After obtaining the FeatureError, as shown in the Handle Result section of the feature overview, we pass the object to the handleError function that is going to analyze what error type occurred in this feature and act according to it.</p> AndroidiOS <p>Example can be found here: FaceCaptureHandleErrors <pre><code>private fun handleError(error: FaceCaptureReportError?) {\n    if (error != null) {\n        val errorType = error.featureError?.errorType ?: ErrorType.UnknownError\n        when (errorType) {\n            ErrorType.InternalError -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", false)\n            }\n            ErrorType.CommunicationError, ErrorType.PermissionNotGrantedError -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", true)\n            }\n            ErrorType.UserRepeated -&gt; {\n                retry()\n            }\n            ErrorType.UserCanceled -&gt; {\n                // User canceled the flow\n                finish()\n            }\n            ErrorType.Timeout -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", true)\n            }\n            ErrorType.FaceCaptureError -&gt; {\n                navigateToFailedTests(error.failedTests ?: emptyList(), error.performedTests ?: emptyList())\n            }\n            else -&gt; {\n                Toast.makeText(this, \"An unknown error occurred\", Toast.LENGTH_SHORT).show()\n                finish()\n            }\n        }\n    }\n}\n</code></pre> The boolean in the navigateToErrorScreen function is to configure if the retry button should appear or not.</p> <p>Example can be found here: Sample Project</p>"},{"location":"Features/FaceCapture/FaceCapture_Index.html","title":"Face Capture","text":"<p>The Mobile ID SDK provides a functionality that simplifies the process of obtaining a frame for biometry checks. To achieve it, we use face detection technology, and capture a frame with the user\u2019s face. The live photo is then processed and checked against a liveness algorithm that will try to detect specific characteristics of spoofing attempts, returning a score that indicates if the person using the app is there or trying to impersonate someone else.</p>"},{"location":"Features/FaceCapture/FaceCapture_Index.html#initiate-face-capture","title":"Initiate Face Capture","text":"<p>The Mobile ID SDK provides a complete set of functionalities that allows capturing and processing the user\u2019s facial characteristics, and match them against the travel document\u2019s photo. This helps ensuring that the user who is enrolling is the document\u2019s owner. The biometric face capture should be the final step before creating a Digital ID in a remote system. If you only need to capture a frame with the user\u2019s face for biometric quality validation and check against liveness algorithms, you can use the method biometricFaceCapture.</p> AndroidiOS <pre><code>/**\n * Uses the device camera to capture a photo of the user face (selfie).\n *\n * Some tests will be run against this photo to ensure the photo quality and a liveness check verification.\n *\n * @param activity [Activity] that will launch the face capture feature\n * @param params [BiometricFaceCaptureParameters] configurations parameters.\n * @param onFaceCaptureComplete [OnBiometricFaceCaptureCompletion] Callback to handle Success and Error scenarios.\n */\nfun biometricFaceCapture(\n    activity: Activity,\n    params: BiometricFaceCaptureParameters,\n    onFaceCaptureComplete: OnBiometricFaceCaptureCompletion,\n)\n</code></pre> <pre><code>/// Uses the device camera to capture a photo of the user face (selfie). Some tests will be run against this photo to ensure the photo quality and a liveness check verification.\n/// - Parameters:\n///   - parameters: Configures the check liveness step.\n///   - viewController: View controller that will present the face capture views.\n///   - completionHandler: The completion handler to call when the face capture feature is finished.\n///     This completion handler takes the following parameter:\n///\n///     Result&lt;BiometricFaceCaptureReport, BiometricFaceCaptureError&gt;\n///     Where `BiometricFaceCaptureReport` contains  the results of the face capture\n///     operation and `FaceCaptureReportError` the possible errors that may occur during the process.\n    func biometricFaceCapture(parameters: BiometricFaceCaptureParameters, viewController: UIViewController, completionHandler: @escaping (Result&lt;BiometricFaceCaptureReport, FaceCaptureReportError&gt;) -&gt; Void)\n</code></pre> <p>The SDK provides UI solutions for the capture process, as shown in the images below. Below is an example of the BiometricFaceCaptureParameters:</p> AndroidiOS <pre><code>data class BiometricFaceCaptureParameters(\n    val frameFormat: FaceCaptureFrameFormat = FaceCaptureFrameFormat.OVAL,\n    val cameraConfig: CameraConfig,\n    val faceCaptureTimeout: Long? = null,\n    val compressFormat: CompressFormat = CompressFormat.PNG\n)\n</code></pre> <p>Now it's also possible to pass the compress format for the resulting biometric face photo format. </p> <p>It defaults to PNG but it's possible to pass other formats such as JPEG.</p> <p>The FaceCaptureFrameFormat is an enum that shapes the frame where the face must be centered to take the selfie. Currently it has two options:</p> <pre><code>enum class FaceCaptureFrameFormat {\n    @Deprecated(message = \"SQUARE shape will be removed in the next major release\", replaceWith = ReplaceWith(\"OVAL\"))\n    SQUARE,\n    OVAL\n}\n</code></pre> <p>The CameraConfig is another data class that lets your configure the visibility of the toggle button and change the camera direction (Front or Back).</p> <p>data class CameraConfig(     val enableCameraToggle: Boolean,     val defaultCamera: CameraSelector, )</p> <pre><code>public struct BiometricFaceCaptureParameters {\n    public let frameShape: BiometricFaceCaptureFrameOptions\n    public let cameraConfig: CameraConfig\n    public let faceCaptureTimeout: TimeInterval?\n\n    public init(frameShape:BiometricFaceCaptureFrameOptions = .oval,\n            cameraConfig: CameraConfig = CameraConfig(),\n            faceCaptureTimeout: TimeInterval? = nil)\n</code></pre> <p>The BiometricFaceCaptureFrameOptions is an enum that shapes the frame where the face must be centered to take the selfie. Currently it has two options:</p> <pre><code>public enum BiometricFaceCaptureFrameOptions {\n    case oval\n    @available(*, deprecated, message: \"Will be removed in future versions (9.x)\")\n    case square\n}\n</code></pre> <p>The CameraConfig is an enum that struct the frame where the face must be centered to take the selfie. Currently it has two options:</p> <pre><code>public struct CameraConfig {\n    public let toggleCameraEnable: Bool\n    public let defaultCamera: AVCaptureDevice.Position\n\n    public init(toggleCameraEnable: Bool = true,\n            defaultCamera:AVCaptureDevice.Position = .front) {\n        self.toggleCameraEnable = toggleCameraEnable\n        self.defaultCamera = defaultCamera\n    }\n}\n</code></pre> <p>This function is used to acquire a high-resolution selfie with a 9:7 aspect ratio. The photo will only be taken if the frame conforms to specific parameters that make sure the face is centered and not too far away, or too close.</p>"},{"location":"Features/FaceCapture/FaceCapture_Index.html#handle-result","title":"Handle Result","text":"AndroidiOS <p>You can get the result by registering the callback: <pre><code>interface OnBiometricFaceCaptureCompletion {\n    fun onBiometricFaceCaptureSuccess(faceCaptureReport: FaceCaptureReportSuccess)\n    fun onBiometricFaceCaptureError(faceCaptureReportError: FaceCaptureReportError)\n}\n</code></pre></p> <pre><code>enrolment?.biometricFaceCapture(parameters: params, viewController: view) { result in\n    switch result {\n    case .success(let report):\n        print(\"Face capture successful.\")\n        completion(.success(()))\n\n    case .failure(let biometricFaceCaptureError):\n        if biometricFaceCaptureError.userCanceled {\n            print(\"Face capture cancelled by user.\")\n            completion(.failure(biometricFaceCaptureError))\n        } else {\n            print(biometricFaceCaptureError.featureError.publicMessage)\n            completion(.failure(biometricFaceCaptureError))\n        }\n    }\n}\n</code></pre>"},{"location":"Features/FaceCapture/FaceCapture_Index.html#face-capture-report","title":"Face Capture Report","text":"<p>You will receive a model of the type FaceCaptureReport that will contain the success data.</p> AndroidiOS <pre><code>data class FaceCaptureReport(\n    val livenessCheckStatus: LivenessCheckStatus,\n    val performedTests: List&lt;String&gt;?,\n    val biometricHash: String\n) : Parcelable\n</code></pre> <pre><code>public struct BiometricFaceCaptureReport: Codable {\n\n    /// Contains the list of biometric process tests performed in Orchestra during the biometric face capture process.\n    public var performedTests: [CheckLivenessTest]\n\n    /// Contains the list of biometric process tests failed in Orchestra during the biometric face capture process.\n    public var failedTests: [CheckLivenessTest]\n\n    /// Flag indicating if liveness check was performed or not during the biometric face capture process.\n    public var performedLivenessCheck: Bool\n\n    /// Biometric photo hash\n    public var biometricHash: String?\n\n    /// Biometric photo\n    public var photo: UIImage? \n\n    public init(photo: UIImage, performedTests: [CheckLivenessTest], failedTests: [String], performedLivenessCheck: Bool, biometricHash: String?)\n}\n</code></pre> <p>The FaceCaptureReportError has the following structure:</p> AndroidiOS <pre><code>data class FaceCaptureReportError(\n    val userCanceled: Boolean,\n    val featureError: FeatureError?,\n    val failedTests: List&lt;String&gt;?,\n    val performedTests: List&lt;String&gt;?\n)\n</code></pre> <pre><code>public class FaceCaptureReportError: Error {\n    public var userCanceled: Bool\n    public var termsAndConditionsAccepted: Bool\n    public var featureError: FeatureError\n    public var failedTests: [String]?\n    public var performedTests: [String]?\n}\n</code></pre> <p>The <code>FaceCaptureReportSuccess</code> includes a <code>biometricHash</code> attribute that needs to be included in the Match operation to verify data integrity. It also used when building a Subject.</p> <p>The failed tests might include one or more of the following tests:</p> Name Description FaceTooFarTest Error indicating that the face was very far. FaceTooCloseTest Error indicating that the face was very close. FaceNotCenteredTest Error indicating that the face was not centered. MultipleFacesDetectedTest Error indicating that multiple faces were detected in the image. FaceRotatedTest Error indicating that the face was rotated in Z angle. A face with a positive Euler Z angle is rotated counter-clockwise relative to the camera. NoFaceDetectedTest Error indicating that no face was detected in the picture. EyesClosedTest Error indicating that the eyes are closed. SmilingTest Error indicating that the user was smiling. FaceSidewaysTest Error indicating that the face was rotated in Y angle. A face with a positive Euler Y angle is looking to the right of the camera, or looking to the left if negative. FaceVerticalTest Error indicating that the face was rotated in X angle. A face with a positive Euler X angle is facing upward. MouthOpenTest Error indicating that the user has the mouth open. ImageBlurredTest Error indicating that the image is blurred. FaceCropFailedTest Error indicating that the face crop failed. LivenessCheckQualityTest Error indicating that the liveness quality test failed. LivenessCheckProbabilityTest Error indicating that the liveness probability test failed."},{"location":"Features/FaceCapture/FaceCapture_Index.html#biometricfacecapturecustomviews","title":"BiometricFaceCaptureCustomViews","text":"<p>The SDK provides default UI solutions for the document reader feature flow, as shown in the following images:</p> <p></p> AndroidiOS <pre><code>@Parcelize\nclass BiometricFaceCaptureCustomViews(\n    val loadingView: Class&lt;out ICustomBiometricFaceCapture.LoadingView&gt;? = null\n) : Parcelable\n</code></pre> <pre><code>public class EnrolmentViewRegister {\n    ...\n\n    public func registerBiometricFaceCaptureLoadingView(_ viewType: FaceCaptureLoadingViewType)\n    ...\n}\n</code></pre> <p>You can use your own custom views in the biometric face capture functionality. Your view must implement the SDK view interfaces. For example, if you want to add a custom loadingView, your view class must implement the ICustomBiometricFaceCapture.LoadingView interface.</p> <p>In the customization tab you will also find examples to create your own custom views.</p>"},{"location":"Features/FaceCapture/FaceCapture_LoadingView.html","title":"Loading View","text":"<p>The only view of the biometric face capture flow is the loading view, it appears when the feature is initializing, when the selfie is being processed and when the liveness service is called.</p> <p></p> <p>It contains a title(1), a message(2), an image(3) and a background that can be customized. </p>"},{"location":"Features/FaceCapture/FaceCapture_LoadingView.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/FaceCapture/FaceCapture_LoadingView.html#text-resources","title":"Text resources","text":"AndroidiOS <p>You can add your own texts and localization by overriding the following string resources: <pre><code>&lt;string name=\"biometric_face_capture_initializing_overlay_title_sdk_enrolment\"&gt;A selfie, please&lt;/string&gt;\n&lt;string name=\"biometric_face_capture_initializing_overlay_subtitle_sdk_enrolment\"&gt;Your selfie will be used to recognize you&lt;/string&gt;\n&lt;string name=\"face_capture_processing_title_sdk_enrolment\"&gt;Just a moment\u2026&lt;/string&gt;\n&lt;string name=\"face_capture_processing_subtitle_sdk_enrolment\"&gt;Processing Photo&lt;/string&gt;\n&lt;string name=\"biometric_face_capture_process_photo_overlay_title_sdk_enrolment\"&gt;We\u2019re checking your picture&lt;/string&gt;\n&lt;string name=\"common_loading_message_sdk_enrolment\"&gt;This will only take a moment&lt;/string&gt;\n</code></pre></p> <p>The best way to override strings is by adding your key through the Theme class</p> <pre><code>Theme.shared.strings.faceCapture.initialization.localized()\nTheme.shared.strings.faceCapture.processingTitle.localized()\nTheme.shared.strings.checkPermission.loadingMessage.localized()\n</code></pre>"},{"location":"Features/FaceCapture/FaceCapture_LoadingView.html#colors","title":"Colors","text":"AndroidiOS <p>You can change the text colors by overriding the following color resource (It affects all texts): <pre><code>&lt;color name=\"colorFaceCaptureTxtDarkSdkEnrolment\"&gt;#1A1C1E&lt;/color&gt;\n</code></pre></p> <p>You can change the background color by overriding the following color resource: <pre><code>&lt;color name=\"colorOverlayFeedbackBgSdkEnrolment\"&gt;#EAEEF6&lt;/color&gt;\n</code></pre></p> <p>You can change the text colors by overriding the following color in Theme class (It affects all Loading Screens):</p> <pre><code>Theme.shared.colors.checkPermission.title\nTheme.shared.colors.checkPermission.subtitle\n</code></pre> <p>You can change the background color by overriding the following color in Theme class(It affects all Loading Screens):</p> <pre><code>Theme.shared.colors.checkPermission.background\n</code></pre>"},{"location":"Features/FaceCapture/FaceCapture_LoadingView.html#styles","title":"Styles","text":"AndroidiOS <p>You can extend the styles we use and override any properties (textColor, textSize, fontFamily, etc...) you want. <pre><code>&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Title.Centered\"&gt;\n&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Subtitle.Centered\"&gt;\n</code></pre> Note: It will affect every component that uses the same style.</p> <p>You can change the font through the theme class (this will affect all text in the app):</p> <pre><code>Theme.shared.fonts.bold\nTheme.shared.fonts.regular\n</code></pre>"},{"location":"Features/FaceCapture/FaceCapture_LoadingView.html#image","title":"Image","text":"AndroidiOS <p>You can change the loading animation by adding a raw json animation file with this name: <pre><code>loading_facecapture.json\n</code></pre></p> <p>You can change the loading image by overriding the following image name in Theme class <pre><code>Theme.shared.images.faceCapture.faceCaptureLoading\nTheme.shared.animations.common.loading\n</code></pre></p>"},{"location":"Features/FaceCapture/FaceCapture_LoadingView.html#use-your-own-layouts","title":"Use your own layouts","text":"AndroidiOS <p>To use your own loading screen for face capture feature, you need to implement the MobileID SDK Interface for that view.</p> <p>In this case: ICustomBiometricFaceCapture.LoadingView <pre><code>interface LoadingView {\n    fun onPreFeatureLoading()\n    fun onFaceProcessLoading()\n    fun onLivenessLoading()\n    fun onPostFeatureLoading()\n    fun hideLoading()\n}\n</code></pre> You can these functions to change loading screen texts in runtime, or you can opt to ignore those functions.</p> <p>For example create a class BiometricFaceCaptureLoadingCustomView, create a layout file and bind it.</p> <pre><code>class CustomFaceCaptureLoadingView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : ConstraintLayout(context, attrs, defStyleAttr), ICustomBiometricFaceCapture.LoadingView {\n\n    init {\n        inflate(context, R.layout.view_biometric_face_capture_init, this)\n    }\n\n    override fun onPreFeatureLoading() {\n    }\n\n    override fun onFaceProcessLoading() {\n    }\n\n    override fun onLivenessLoading() {\n    }\n\n    override fun onPostFeatureLoading() {\n    }\n\n    override fun hideLoading() {\n    }\n}\n</code></pre> <p>You need to register a class of type FaceCaptureLoadingViewType through the following function of EnrolmentViewRegister <pre><code>public func registerBiometricFaceCaptureLoadingView(_ viewType: FaceCaptureLoadingViewType)\n</code></pre></p> <p>The FaceCaptureLoadingViewType class needs to respect the following protocols:</p> <pre><code>public protocol FeatureLoadingViewInterface {\n    func onPreFeatureLoading()\n    func onPostFeatureLoading()\n    func hideLoading()\n}\n\npublic typealias FeatureLoadingViewType = FeatureLoadingView.Type\npublic typealias FeatureLoadingView = UIView &amp; FeatureLoadingViewInterface\n\npublic protocol FaceCaptureLoadingViewInterface: FeatureLoadingView {\n    // called while processing is running.\n    func onFaceProcessLoading()\n\n    // called when liveness is being checked.\n    func onLivenessLoading()\n}\n\npublic typealias FaceCaptureLoadingViewType = FaceCaptureLoadingView.Type\npublic typealias FaceCaptureLoadingView = UIView &amp; FaceCaptureLoadingViewInterface\n</code></pre> <p>Example: <pre><code>class LoadingView: FaceCaptureLoadingView {\n\n    // MARK: - Initialization\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        //add any UI customization you need\n    }\n\n    // MARK: - Functions\n\n    func onPreFeatureLoading() {\n        //add any UI customization you need\n    }\n\n    func onPostFeatureLoading() {\n        //add any UI customization you need\n    }   \n\n    func onFaceProcessLoading(){\n        //add any UI customization you need\n    }\n\n    func onLivenessLoading(){\n        //add any UI customization you need\n    }\n\n    func hideLoading() {\n        //You can stop animations or other activities that consumes resources \n    }\n}\n</code></pre></p>"},{"location":"Features/FaceCapture/FaceCapture_PreviewView.html","title":"Preview View","text":"<p>From version 8 onwards, the preview management changed in the SDK to make it easier to integrate.</p> <p>To improve flexibility in the preview screen, the optional preview screen has been removed.</p> <p>To add a preview feature to your app you can follow the example from our sample app, where we provide an example with the same user interface.</p> AndroidiOS <p>Example can be found here: FaceCapturePreview <pre><code>private fun onSuccess(faceCaptureSuccess: FaceCaptureReportSuccess) {\n    val photo = readPhotoFromInternalStorage(context, faceCaptureSuccess.faceCaptureReport.faceCaptureImagePath)\n    binding.imgFaceCapturePhoto.run {\n        setBackgroundResource(R.drawable.bg_face_capture_preview_image)\n        setImageBitmap(photo)\n    }\n}\n</code></pre></p> <p>Example can be found here: Sample Project</p>"},{"location":"Features/FaceCapture/FaceCapture_ScanView.html","title":"Scan View","text":"<p>The camera screen is no longer a custom view in order to allow us to better control the user flow. You can still apply any branding you want to the screen and change the frame format by using our FaceCaptureFrameFormat enum in the feature parameters.</p> <p></p> <p>It contains a title(1), a message(2), a cancel button(3), a frame(4) and a rotate camera button(5).</p>"},{"location":"Features/FaceCapture/FaceCapture_ScanView.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/FaceCapture/FaceCapture_ScanView.html#text-resources","title":"Text resources","text":"AndroidiOS <p>You can add your own texts and localization by overriding the following string resources: <pre><code>&lt;!-- Default messages--&gt;\n&lt;string name=\"face_capture_no_face_title_sdk_enrolment\"&gt;Let\\'s frame your face\u2026&lt;/string&gt;\n&lt;string name=\"face_capture_no_face_subtitle_sdk_enrolment\"&gt;Stand still, please&lt;/string&gt;\n\n&lt;!-- Possible title messages--&gt;\n&lt;string name=\"face_capture_processing_title_sdk_enrolment\"&gt;Just a moment\u2026&lt;/string&gt;\n&lt;string name=\"face_capture_mouth_open_title_sdk_enrolment\"&gt;Prepare to take a selfie&lt;/string&gt;\n&lt;string name=\"face_capture_invalid_rotation_title_sdk_enrolment\"&gt;Prepare to take a selfie&lt;/string&gt;\n&lt;string name=\"face_capture_invalid_verticalness_title_sdk_enrolment\"&gt;Prepare to take a selfie&lt;/string&gt;\n&lt;string name=\"face_capture_too_far_title_sdk_enrolment\"&gt;Prepare to take a selfie&lt;/string&gt;\n&lt;string name=\"face_capture_too_close_title_sdk_enrolment\"&gt;Prepare to take a selfie&lt;/string&gt;\n&lt;string name=\"face_capture_not_centered_title_sdk_enrolment\"&gt;Prepare to take a selfie&lt;/string&gt;\n&lt;string name=\"face_capture_multiple_faces_detected_title_sdk_enrolment\"&gt;Prepare to take a selfie&lt;/string&gt;\n&lt;string name=\"face_capture_no_face_title_sdk_enrolment\"&gt;Let\\'s frame your face\u2026&lt;/string&gt;\n&lt;string name=\"face_capture_eyes_closed_title_sdk_enrolment\"&gt;Prepare to take a selfie&lt;/string&gt;\n&lt;string name=\"face_capture_smiling_title_sdk_enrolment\"&gt;Prepare to take a selfie&lt;/string&gt;\n&lt;string name=\"face_capture_face_sideways_title_sdk_enrolment\"&gt;Prepare to take a selfie&lt;/string&gt;\n\n&lt;!-- Possible subtitle messages--&gt;\n&lt;string name=\"face_capture_processing_subtitle_sdk_enrolment\"&gt;Processing Photo&lt;/string&gt;\n&lt;string name=\"face_capture_mouth_open_subtitle_sdk_enrolment\"&gt;Close your mouth&lt;/string&gt;\n&lt;string name=\"face_capture_invalid_rotation_subtitle_sdk_enrolment\"&gt;Straighten your head&lt;/string&gt;\n&lt;string name=\"face_capture_invalid_verticalness_subtitle_sdk_enrolment\"&gt;Don\\'t look up/down&lt;/string&gt;\n&lt;string name=\"face_capture_too_far_subtitle_sdk_enrolment\"&gt;Approximate please&lt;/string&gt;\n&lt;string name=\"face_capture_too_close_subtitle_sdk_enrolment\"&gt;Go back please&lt;/string&gt;\n&lt;string name=\"face_capture_not_centered_subtitle_sdk_enrolment\"&gt;Center your head&lt;/string&gt;\n&lt;string name=\"face_capture_multiple_faces_detected_subtitle_sdk_enrolment\"&gt;Multiple faces detected&lt;/string&gt;\n&lt;string name=\"face_capture_ready_subtitle_sdk_enrolment\"&gt;One moment, please&lt;/string&gt;\n&lt;string name=\"face_capture_eyes_closed_subtitle_sdk_enrolment\"&gt;Open your eyes please&lt;/string&gt;\n&lt;string name=\"face_capture_smiling_subtitle_sdk_enrolment\"&gt;Keep a straight face&lt;/string&gt;\n&lt;string name=\"face_capture_face_sideways_subtitle_sdk_enrolment\"&gt;Look to the camera&lt;/string&gt;\n</code></pre></p> <p>The best way to override strings is by adding your key through the Theme class  </p> <pre><code>//Possible title messages\nTheme.shared.strings.faceCapture.titleNoFace.localized()\nTheme.shared.strings.faceCapture.titleCountDown.localized()\nTheme.shared.strings.faceCapture.titleDone.localized()\nTheme.shared.strings.faceCapture.title.localized()\n\n\n//Possible subtitle messages\nTheme.shared.strings.faceCapture.info.localized()\nTheme.shared.strings.faceCapture.infoCountDown.localized()\nTheme.shared.strings.faceCapture.noFaceDetected.localized()\nTheme.shared.strings.faceCapture.turnedHead.localized()\nTheme.shared.strings.faceCapture.closedEyes.localized()\nTheme.shared.strings.faceCapture.smiling.localized()\nTheme.shared.strings.faceCapture.openMouth.localized()\nTheme.shared.strings.faceCapture.headOffCenter.localized()\nTheme.shared.strings.faceCapture.tooClose.localized()\nTheme.shared.strings.faceCapture.tooFar.localized()\nTheme.shared.strings.faceCapture.ready.localized()\nTheme.shared.strings.faceCapture.multipleFaces.localized()\nTheme.shared.strings.faceCapture.darkGlasses.localized()\nTheme.shared.strings.faceCapture.lowFaceQuality.localized()\nTheme.shared.strings.faceCapture.imageBlurredError.localized()\n</code></pre>"},{"location":"Features/FaceCapture/FaceCapture_ScanView.html#colors","title":"Colors","text":"AndroidiOS <p>You can change the text colors by overriding the following color resource (It affects all texts): <pre><code>&lt;color name=\"colorFaceCaptureTxtLightSdkEnrolment\"&gt;#DFFFFFFF&lt;/color&gt;\n\n&lt;!-- Rotate camera button --&gt;\n&lt;color name=\"colorFaceCaptureButtonStrokeSdkEnrolment\"&gt;#FFFFFF&lt;/color&gt;\n&lt;color name=\"colorFaceCaptureButtonBgSdkEnrolment\"&gt;#CFD8DC&lt;/color&gt;\n</code></pre></p> <p>You can change the text colors by overriding the following color in Theme class <pre><code>Theme.shared.colors.faceCapture.title\nTheme.shared.colors.faceCapture.stateLabel\n</code></pre></p> <p>You can change the frame colors by overriding the following color in Theme class <pre><code>Theme.shared.colors.common.black\nTheme.shared.colors.faceCapture.stateError\nTheme.shared.colors.faceCapture.stateValid\n</code></pre></p> <p>You can change the mask and flash colors by overriding the following color in Theme class <pre><code>Theme.shared.colors.component.transparentOverlay\nTheme.shared.colors.faceCapture.flash\n</code></pre></p> <p>You can change the rotate camera button colors by overriding the following color in Theme class <pre><code>Theme.shared.colors.faceCapture.cameraSwitchButtonImageTint\nTheme.shared.colors.faceCapture.cameraSwitchButtonBackground\n</code></pre></p>"},{"location":"Features/FaceCapture/FaceCapture_ScanView.html#styles","title":"Styles","text":"AndroidiOS <p>You can extend the styles we use and override any properties (textColor, textSize, fontFamily, etc...) you want. <pre><code>&lt;style name=\"Theme.Sdk.Enrolment.TextView.Light.Title.Centered\"&gt;\n&lt;style name=\"Theme.Sdk.Enrolment.TextView.Light.Subtitle.Centered\"&gt;\n&lt;style name=\"Theme.Sdk.Enrolment.ButtonCancel\"&gt;\n&lt;style name=\"Theme.Sdk.Enrolment.Face.Capture.Button\"&gt;\n</code></pre> Note: It will affect every component that uses the same style.</p> <p>You can change the font through the theme class (this will affect all text in the app):</p> <pre><code>Theme.shared.fonts.regular\n</code></pre>"},{"location":"Features/FaceCapture/FaceCapture_ScanView.html#image","title":"Image","text":"AndroidiOS <p>You can change the icon of the rotate camera button by adding a drawable with this name: <pre><code>ic_flip_camera.xml\n</code></pre> The image we are using is 48x48dp.</p> <p>You can change the icon of the cancel button by adding a drawable with this name: <pre><code>ic_cancel_sdk_enrolment.xml\n</code></pre> The image we are using is 24x24dp.</p> <p>You can change the icon of the cancel button by overriding the following image in Theme class <pre><code>Theme.shared.images.buttons.closeButton\n</code></pre></p> <p>You can change the icon of the rotate camera button by overriding the following image in Theme class <pre><code>Theme.shared.images.faceCapture.toggleCameraButton\n</code></pre></p>"},{"location":"Features/Form/Form_Index.html","title":"Form","text":"<p>Form is a feature that allows you to collect additional data and attach it to created subjects. The supported built-in data is currently:</p> <ul> <li>Email</li> <li>Text</li> </ul> <p>You can then submit this data, alongside your subject, through the AddSubjectParameters.</p> <p>To start the form feature, you can use the enrolment method</p> AndroidiOS <pre><code>   /**\n * @param activity [Activity] that will launch the face capture feature\n * @param onFormCompletion [OnFormCompletion] callback to handle Success and Error scenarios\n */\nfun startForm(\n    activity: Activity,\n    onFormCompletion: OnFormCompletion,\n)\n</code></pre> <pre><code>// MARK: - FormFeature\n/// - Parameters:\n///   - parameters: Parameters for Form feature flow.\n///   - viewController: The view controller that will present the FormFeature.\n///   - completionHandler: The completion handler to call when the boarding pass parser feature is finished.\n///     This completion handler takes the following parameter:\n///\n///     Result&lt;FormReport, FormError&gt;\n///     Where `FormReport` contains  the form data and\n///     `FeatureError` the possible errors that may occur during the process.\nfunc startForm(parameters: FormParameters, viewController: UIViewController, completionHandler: @escaping (Result&lt;FormReport, FormError&gt;) -&gt; Void)\n</code></pre>"},{"location":"Features/Form/Form_Index.html#handle-result","title":"Handle Result","text":"AndroidiOS <p>Here's how you can get the result by using the form callback:</p> <pre><code>interface OnFormCompletion {\n    fun onFormSuccess(formAnswer: FormAnswer)\n    fun onFormError(formError: FormError)\n}\n</code></pre> <p>FormAmswer on the success callback is defined as:</p> <pre><code>data class FormAnswer(\n    val formId: String,\n    val answers: List&lt;Answer&gt;\n)\n</code></pre> <p>Here's how you can get the report by calling the startForm function.</p> <pre><code>enrolment?.startForm(parameters: params, viewController: view, completionHandler: { result in\n    switch result {\n    case .success(let report):\n        // save report \n        completion(.success(()))\n    case .failure(let error):\n        completion(.failure(error))\n    }\n})\n</code></pre> <p>The FormReport has the following structure:</p> <pre><code>public struct FormReport {\n    let answer: [FormAnswer]\n\n    init(answer: [FormAnswer]) {\n        self.answer = answer\n    }\n}  \n</code></pre> <p>The FormAnswer has the following structure:</p> <pre><code>public class FormAnswer: Codable {\n    var formId: String\n    var answers: [Answer]\n\n    init(formId: String, answers: [Answer]) {\n        self.formId = formId\n        self.answers = answers\n    }\n}\n</code></pre> <p>The Answer has the following structure:</p> <pre><code>public class Answer: Codable{\n    var questionId: String\n    var value: String\n\n    init(questionId: String, value: String) {\n        self.questionId = questionId\n        self.value = value\n    }\n}\n</code></pre> <p>The FormError has the following structure:</p> AndroidiOS <pre><code>data class FormError(\n    val userCanceled: Boolean = false,\n    val termsAndConditionsAccepted: Boolean = true,\n    val featureError: FeatureError? = null\n)\n</code></pre> <pre><code>public class FormError: Error {\n    public var userCanceled: Bool\n    public var termsAndConditionsAccepted: Bool\n    public var featureError: FeatureError\n}\n</code></pre>"},{"location":"Features/SubjectManagement/SubjectManagement_HandleErrors.html","title":"Handle Errors","text":"<p>After obtaining the FeatureError, as shown in the Handle Result section of the feature overview, we pass the object to the handleError function that is going to analyze what error type occurred in this feature and act according to it.</p> AndroidiOS <p>Example can be found here: SubjectHandleErrors <pre><code>private fun handleError(error: FaceCaptureReportError?) {\n    if (error != null) {\n        val errorType = error.featureError?.errorType ?: ErrorType.UnknownError\n        when (errorType) {\n            ErrorType.InternalError -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", false)\n            }\n            ErrorType.CommunicationError,\n            ErrorType.SubjectError -&gt; {\n                navigateToErrorScreen(error.featureError?.publicMessage ?: error.featureError?.description ?: \"\", true)\n            }\n            ErrorType.UserRepeated -&gt; {\n                retry()\n            }\n            ErrorType.UserCanceled -&gt; {\n                // User canceled the flow\n                finish()\n            }\n            else -&gt; {\n                Toast.makeText(this, \"An unknown error occurred\", Toast.LENGTH_SHORT).show()\n                finish()\n            }\n        }\n    }\n}\n</code></pre> The boolean in the navigateToErrorScreen function is to configure if the retry button should appear or not.</p> <p>Example can be found here: Sample Project</p>"},{"location":"Features/SubjectManagement/SubjectManagement_Index.html","title":"Subject Manager","text":"<p>A <code>Subject</code> consists of a set of data that represents a digital ID in the enrolment process. The Mobile ID SDK provides the ability to build and create such <code>Subject</code>.</p>"},{"location":"Features/SubjectManagement/SubjectManagement_Index.html#use-subject-manager","title":"Use Subject Manager","text":"<p>You can manage subjects using the subject management functions available in the enrolment facade. Subjects are the result of the enrolment process and need to be successfully created in the server-side platform, to complete any process requiring a digital form of identification. The subject will always be null when returned from the facade's method subject builder. This field will only be filled by our backend services, depending on if the subject is fully authenticated or not. If the user is not fully authenticated, the subject token will be filled only on when the app fetches the subject on the facade's get subject method. If the subject token is not null, it will contain a base 64 QR code that the user must present on the physical gate for a full authentication.</p> AndroidiOS <pre><code>data class Subject(\n    val id: String?,\n    val language: String,\n    val document: Document,\n    val biometrics: List&lt;Biometric&gt;,\n    val validationStatus: ValidationStatus,\n    val subjectToken: SubjectToken?,\n    var boardingPass: BoardingPass? = null\n)\n</code></pre> <pre><code>public struct Subject {\n    public let id: String\n    public let document: Document\n    public let biometrics: [Biometric]?\n    public var boardingPass: BoardingPass?\n    public var validationStatus: ValidationStatus\n    public var subjectToken: SubjectToken?\n    public var language: Locale\n    public var formData: [FormAnswer]?\n}\n</code></pre> <p>The subject <code>id</code> will be generated and returned upon adding it for the first time.</p> <p>The SubjectToken will have the following structure:</p> AndroidiOS <p>The SubjectToken will also provide a method to return the QR code as a bitmap. For this you just need to call the method getQRCodeImage().</p> <pre><code>data class SubjectToken(\n    val qrCodeBase64: String\n)\n</code></pre> <pre><code>public struct SubjectToken {\n    public var qrCodeBase64: String\n    public var qrCodeImage: UIImage?\n}\n</code></pre> <p>The ValidationStatus will have the following structure:   </p> AndroidiOS <pre><code>data class ValidationStatus(\n    val documentAuthenticated: Boolean,\n    val livenessCheckPassed: Boolean,\n    val biometryMatched: Boolean\n)\n</code></pre> <pre><code>public struct ValidationStatus {\n    /// Field indicating if the Enrolment photos matched.\n    public var biometryMatched: Bool\n    /// Field indicating if the liveness check test was performed with success.\n    public var livenessCheckPassed: Bool\n    /// Field indicating if the RFID scan of the document was performed with success.\n    public var documentAuthenticated: Bool\n}\n</code></pre> <p>Check the Document, BoardingPass and Biometric pages for more information about the remaining attributes.</p>"},{"location":"Features/SubjectManagement/SubjectManagement_Index.html#subject-operations","title":"Subject operations","text":"<p>You can create a new subject using the <code>addSubject</code> method. <code>Subject</code> data can be automatically submitted to the server-side platform after a successful document read and face matching operation, as shown in the following example:</p> AndroidiOS <pre><code>/**\n * Adds a [Subject].\n *\n * @param context Context\n * @param params contains instance from [Subject] that will be added in the server.\n * @param resultLauncher [ActivityResultLauncher&lt;Intent&gt;] fragment or activity that will handle the results .\n */\nfun addSubject(\n    context: Context,\n    params: AddSubjectParameters,\n    resultLauncher: ActivityResultLauncher&lt;Intent&gt;\n)\n</code></pre> <pre><code>/// Saves a Subect to server.\n/// - Parameters:\n///   - parameters: Parameteres for the Add Subject flow.\n///   - viewController: View controller base from when to present required SDK view controllers.\n///   - completionHandler: The completion handler to call when the add subject operation is finished.\n///     This completion handler takes the following parameter:\n///\n///     Result&lt;Void, SubjectError&gt;\n///     Where `SubjectError` contains the possible errors that may occur during the process.\nfunc addSubject(parameters: AddSubjectParameters, viewController: UIViewController, completionHandler: @escaping (Result&lt;Void, SubjectError&gt;) -&gt; Void)\n</code></pre> <p>If you just need to build a subject, you must have the documentData object. The <code>documentData</code> must be filled by the client app, or it can be acquired from the DocumentReaderReport when scanning with the SDK scan document feature. The <code>documentPhoto</code> and <code>enrolmentPhoto</code> can be acquired from the Document Reader and the Face Capture features respectively. The <code>boardingPass</code> object can be acquired from the Boarding Pass Reader. The <code>matchReport</code> is a result of using the facade's face match feature. The <code>language</code> field is, by default, the locale in use on the device, allows the user to continue the enrollment in a kiosk with the correct language and it can be changed by client apps. With this data you can create the <code>BuildSubjectParameters</code> object. This object has the following structure:</p> AndroidiOS <pre><code>data class BuildSubjectParameters(\n    val documentData: DocumentData,\n    val documentPhoto: Bitmap?,\n    val enrolmentPhoto: Bitmap,\n    val boardingPass: BoardingPass? = null,\n    val processReport: FaceCaptureReport? = null,\n    val matchReport: MatchReport? = null,\n    val documentReaderReport: DocumentReaderReport? = null,\n    val language: Locale? = null,\n)\n</code></pre> <pre><code>public struct BuildSubjectParameters {\n    public let documentData: DocumentData?\n    public let idDocument: IdDocument?\n    public let documentDataValidated: Bool\n    public let documentImage: UIImage\n    public let enrolmentImage: UIImage\n    public let boardingPass: BoardingPassSummary?\n    public let language: Locale\n    public let formReport: FormReport?\n    public let processReport: BiometricFaceCaptureReport?\n    public let documentReaderReport: DocumentReaderReport?\n\n    public init(\n        documentData: DocumentData? = nil,\n        idDocument: IdDocument? = nil,\n        documentImage: UIImage,\n        enrolmentImage: UIImage,\n        boardingPass: BoardingPassSummary?,\n        documentReaderReport: DocumentReaderReport? = nil,\n        biometricFaceCaptureReport: BiometricFaceCaptureReport? = nil,\n        matchReport: MatchReport? = nil,\n        language: Locale? = nil,\n        formReport: FormReport? = nil\n    )\n}\n</code></pre> <p>The following example shows how you can build a subject:</p> AndroidiOS <pre><code>launch {\n    val params = BuildSubjectParameters(\n        documentData = documentData,\n        documentPhoto = documentPhoto,\n        enrolmentPhoto = enrolmentPhoto,\n        boardingPass = boardingPass,\n        processReport = processReport,\n        matchReport = matchReport,\n        documentReaderReport = documentReaderReport\n    )\n    val result = enrolment.buildSubject(params)\n}\n</code></pre> <p>Warning</p> <p>Because the Subject model might become a big object it may cause the parcelable too large exception. For this reason, it\u2019s not parcelable. If you need to transform the Subject model in a parcelable object, you can use the helper method <code>toSubjectParcelable()</code> and after using it on a Bundle, you should reconvert it to a Subject using the method <code>toSubject()</code>.</p> <pre><code>let parameters = BuildSubjectParameters(\n    documentData: documentData,\n    documentImage: documentImage,\n    enrolmentImage: enrolmentImage,\n    boardingPass: EnrolmentData.shared.boardingPass,\n    documentReaderReport: EnrolmentData.shared.documentReaderReport,\n    biometricFaceCaptureReport: EnrolmentData.shared.biometricMatchReport,\n    matchReport: EnrolmentData.shared.matchReport,\n    language: Locale.current\n)\n\nguard let vco = self.view as? UIViewController else {\n    return\n}\n\nself.enrolment.buildSubject(\n    parameters: parameters,\n    viewController: vco) { [weak self] result in\n    switch result {\n    case .success(let subject):\n        self?.addSubject(subject: subject)\n    case .failure:\n        self?.view?.onBuildSubjectError()\n    }\n}\n</code></pre> <p>The SDK does not provide any UI solutions for subject representation. You should build your own layouts and use the information that is relevant for your mobile solution.</p> <p>These are all the subject methods: </p> AndroidiOS <pre><code>/**\n* Builds a [Subject] instance with the given [params].\n*\n* @param params [BuildSubjectParameters] that contains the necessary data to build the subject.\n* @return a [Result] with a [Subject] or [SubjectBuilderError].\n*/\nfun buildSubject(\n    activity: Activity,\n    params: BuildSubjectParameters\n): Result&lt;Subject, SubjectBuilderError&gt;\n\n/**\n * Adds a [Subject].\n *\n * @param context Context\n * @param params contains instance from [Subject] that will be added in the server.\n * @param resultLauncher [ActivityResultLauncher&lt;Intent&gt;] fragment or activity that will handle the results .\n */\nfun addSubject(\n    context: Context,\n    params: AddSubjectParameters,\n    resultLauncher: ActivityResultLauncher&lt;Intent&gt;\n)\n</code></pre> <pre><code>/// Build a Subject from document data. Can, optionally, receive a boarding pass.\n/// - Parameters:\n///   - parameters: Parameters for the Building Subject flow.\n///   - viewController: View controller base from when to present required SDK view controllers.\n///   - completionHandler: The completion handler to call when the build subject operation is finished.\n///     This completion handler takes the following parameter:\n///\n///     Result&lt;Subject, SubjectBuilderError&gt;\n///     Where `Subject` contains  the subject information and `SubjectError`\n///     the possible errors that may occur during the process.\nfunc buildSubject(parameters: BuildSubjectParameters, viewController: UIViewController, completionHandler: @escaping (Result&lt;Subject, SubjectError&gt;) -&gt; Void)\n\n/// Saves a Subect to server.\n/// - Parameters:\n///   - parameters: Parameteres for the Add Subject flow.\n///   - viewController: View controller base from when to present required SDK view controllers.\n///   - completionHandler: The completion handler to call when the add subject operation is finished.\n///     This completion handler takes the following parameter:\n///\n///     Result&lt;Void, SubjectError&gt;\n///     Where `SubjectError` contains the possible errors that may occur during the process.\nfunc addSubject(parameters: AddSubjectParameters, viewController: UIViewController, completionHandler: @escaping (Result&lt;Void, SubjectError&gt;) -&gt; Void)\n</code></pre> <p>Adding a <code>Subject</code> required the AddSubjectParameters which have the following structure:   </p> AndroidiOS <pre><code>data class AddSubjectParameters(\n    val subject: Subject,\n    val formAnswer: FormAnswer? = null,\n)\n</code></pre> <pre><code>public struct AddSubjectParameters {\n    public let subject: Subject\n\n    public init(subject: Subject)\n}\n</code></pre>"},{"location":"Features/SubjectManagement/SubjectManagement_Index.html#handle-result","title":"Handle Result","text":"AndroidiOS <p>You can get the result by registering the callback. In this instance, the subjectId of the created Subject will be returned in the case of a success. <pre><code>interface OnAddSubjectCompletion {\n    fun onAddSubjectSuccess(subjectId: String)\n    fun onAddSubjectError(subjectError: SubjectError)\n}\n</code></pre></p> <pre><code>self.enrolment.addSubject(\n    parameters: AddSubjectParameters(subject: subject),\n    viewController: vco) { [weak self] result in\n\n    switch result {\n    case .success:\n        print(\"Add Subject: Success!\")\n    case .failure(let error):\n        print(error.featureError.publicMessage)\n    }\n}\n</code></pre> <p>The SubjectError has the following structure:</p> AndroidiOS <pre><code>data class SubjectError(\n    val userCanceled: Boolean,\n    val featureError: FeatureError?\n)\n</code></pre> <pre><code>public class SubjectError: Error {\n    public var userCanceled: Bool\n    public var termsAndConditionsAccepted: Bool\n    public var featureError: FeatureError\n}\n</code></pre>"},{"location":"Features/SubjectManagement/SubjectManagement_Index.html#biometric","title":"Biometric","text":"<p>The <code>biometrics</code> attribute on the <code>Subject</code> is a list of biometric data. This biometric data contains its source, a base64 of the image and it's format, which you can get the image bitmap by calling the method getBiometricImage(), type and position. Here is the structure of the Biometric data:</p> AndroidiOS <pre><code>data class Biometric(\n    val source: BiometricSource,\n    val data: String,\n)\n</code></pre> <pre><code>public struct Biometric {\n    public let type: BiometricType\n    public let format: BiometricFormat\n    public let position: BiometricTypePosition\n    public let source: BiometricSource\n    public let data: Data\n    public let photo: UIImage?\n}\n</code></pre> <p>The <code>BiometricFormat</code> will specify the format for the <code>data</code> string like so:</p> AndroidiOS <pre><code>/**\n* Biometric format type for both Face and Document captures\n*/\nenum class BiometricFormat {\n    Unknown, Jpg, Png\n}\n</code></pre> <pre><code>public enum BiometricFormat: String {\n    case unknown = \"Unknown\"\n    case jpg = \"Jpg\"\n    case png = \"Png\"\n}\n</code></pre> <p>The <code>BiometricSource</code> is a enum with the source of the biometric photo and will have the following structure:</p> AndroidiOS <pre><code>/**\n* Source of the provided photo. Identifies how it was obtained.\n*/\nenum class BiometricSource {\n    Unknown,\n    Face,\n    Ocr,\n    Chip\n}\n</code></pre> <pre><code>public enum BiometricSource: String {\n    case documentChip = \"Chip\"\n    case documentOCR = \"Ocr\"\n    case faceCapture = \"Face\"\n}\n</code></pre> <p>The <code>BiometricType</code> defines the capture type of the biometric:</p> AndroidiOS <pre><code>/**\n * Biometrics type for the Face capture\n */\nenum class BiometricType {\n    Unknown, Enrolment\n}\n</code></pre> <pre><code>  public enum BiometricType: String {\n    case unknown = \"Unknown\"\n    case enrolment = \"Enrolment\"\n}\n</code></pre> <p>The <code>BiometricPosition</code> is something only present on face captured Biometrics </p> AndroidiOS <pre><code>    /**\n    * Biometric position of the source in question\n    */\n    enum class BiometricPosition {\n        Unknown, Face\n    }\n</code></pre> <pre><code>public enum BiometricTypePosition: String {\n    case unknown = \"Unknown\"\n    case face = \"Face\"\n}\n</code></pre>"},{"location":"Features/SubjectManagement/SubjectManagement_Index.html#subject-status","title":"Subject Status","text":"<p>After adding a <code>Subject</code>, the <code>id</code> will be returned. This <code>id</code> can be used to get the <code>SubjectStatus</code> which will contain information about the current status of a given <code>Subject</code>.</p> AndroidiOS <pre><code>    data class SubjectStatus(val subjectId: String?, val status: Status, val detail: String?) {\n\n        enum class Status {\n            Pending,\n            Validating,\n            Invalid,\n            Enrolled,\n            Expired\n        }\n    }\n</code></pre> <pre><code>public struct SubjectStatus {\n    public let id: String\n    public let status: Status\n}\n</code></pre> <p>The <code>SubjectStatus</code> is accessible through the <code>Enrolment</code> by calling one these methods below and registering the <code>OnSubjectStatusResult</code> callback.</p> AndroidiOS <pre><code>/**\n * Gets the [Subject] status for the given subjectId.\n *\n * @param subjectId of the specified [Subject]\n * @param listener to get the result back\n */\nfun getSubjectStatus(\n    subjectId: String,\n    listener: OnSubjectStatusResult\n)\n\n/**\n * Gets a list of [SubjectStatus] for this device \n *\n * @param listener callback to get the [SubjectStatus] back\n */\nfun getAllSubjectStatus(\n    listener: OnSubjectStatusResult\n)\n\n/**\n * Callback for Success and Error when fetching a single or multiple [SubjectStatus]\n */\ninterface OnSubjectStatusResult {\n\n    /**\n     * Success callback\n     *\n     * @param status contains a list of [SubjectStatus] returning the [Subject] id and it's [SubjectStatus.Status]\n     */\n    fun onStatus(status: List&lt;SubjectStatus&gt;)\n\n    /**\n     * Error callback\n     */\n    fun onError(error: String)\n}\n</code></pre> <pre><code>/// Get all status from server.\n///     /// - Parameters:\n///   - completionHandler: The completion handler to call when the get status operation is finished.\n///     This completion handler takes the following parameter:\n///\n///     Result&lt;[SubjectStatus], SubjectError&gt;\n///     Where `SubjectError` contains the possible errors that may occur during the process.\nfunc getStatus(completionHandler: @escaping (Result&lt;[SubjectStatus], SubjectError&gt;) -&gt; Void)\n\n/// Get  status by id from server.\n/// - Parameters:\n///   - subjectId: id to retrive\n///   - completionHandler: The completion handler to call when the get status operation is finished.\n///     This completion handler takes the following parameter:\n///\n///     Result&lt;[SubjectStatus], SubjectError&gt;\n///     Where `SubjectError` contains the possible errors that may occur during the process.\n\nfunc getStatus(subjectId:String, completionHandler: @escaping (Result&lt;SubjectStatus, SubjectError&gt;) -&gt; Void)\n</code></pre>"},{"location":"Features/SubjectManagement/SubjectManagement_Index.html#subjectcustomviews","title":"SubjectCustomViews","text":"<p>The SDK provides default UI solutions for the Subject Management feature flow, as shown in the following images:</p> <p></p> <p>You can also apply your app\u2019s colors and fonts to these layout solutions, to keep your brand\u2019s image consistent. Check Customization tab to learn more about branding of each view.</p> AndroidiOS <p><pre><code>@Parcelize\nclass SubjectCustomViews(\n    val loadingView: Class&lt;out ICustomSubject.LoadingView&gt;? = null\n) : Parcelable\n</code></pre> You can use your own custom views in the subject functionality. Your view must implement the SDK view interfaces. For example, if you want to add a custom loading view, your view class must implement the ICustomSubject.LoadingView interface.</p> <p><pre><code>public class EnrolmentViewRegister {\n    ...\n\n    // MARK: - Subject Operations\n    public func registerSubjectLoadingOverlayView(_ viewType: SubjectLoadingOverlayViewType)\n    ...\n}\n</code></pre> You can use your own custom views in the subject functionality. Your view must implement the SDK view protocols. For example, if you want to add a custom loading view, your view class must implement the ICustomSubject.LoadingView interface.</p>"},{"location":"Features/SubjectManagement/SubjectManagement_LoadingView.html","title":"Loading View","text":"<p>The only view of the Subject flow is the loading view, appears when the SDK is doing an operation on the subject and communicates it to the server</p> <p></p> <p>It contains a title(1), a message(2), an image(3) and a background that can be customized.</p>"},{"location":"Features/SubjectManagement/SubjectManagement_LoadingView.html#branding","title":"Branding","text":"<p>You can apply your own branding to our screens by overriding the resources we use.</p>"},{"location":"Features/SubjectManagement/SubjectManagement_LoadingView.html#text-resources","title":"Text resources","text":"AndroidiOS <p>You can add your own texts and localization by overriding the following string resources: <pre><code>&lt;string name=\"subject_loading_title_sdk_enrolment\"&gt;Creating your Digital ID&lt;/string&gt;\n&lt;string name=\"subject_adding_subject_sdk_enrolment\"&gt;Adding subject\u2026&lt;/string&gt;\n&lt;string name=\"subject_getting_subject_sdk_enrolment\"&gt;Getting subject\u2026&lt;/string&gt;\n&lt;string name=\"subject_updating_subject_sdk_enrolment\"&gt;Updating subject\u2026&lt;/string&gt;\n&lt;string name=\"subject_deleting_subject_sdk_enrolment\"&gt;Deleting subject\u2026&lt;/string&gt;\n&lt;string name=\"subject_adding_boarding_pass_sdk_enrolment\"&gt;Adding boarding pass\u2026&lt;/string&gt;\n&lt;string name=\"subject_deleting_boarding_pass_sdk_enrolment\"&gt;Deleting boarding pass\u2026&lt;/string&gt;\n&lt;string name=\"common_loading_message_sdk_enrolment\"&gt;This will only take a moment&lt;/string&gt;\n&lt;string name=\"feature_permission_loading_message_sdk_enrolment\"&gt;Please wait\u2026&lt;/string&gt;\n</code></pre></p> <p>The best way to override strings is by adding your key through the Theme class <pre><code>Theme.shared.strings.subject.addSubjectLoadingTitle\nTheme.shared.strings.subject.addSubjectLoadingMessage\n\nTheme.shared.strings.subject.getSubjectLoadingTitle\nTheme.shared.strings.subject.getSubjectLoadingMessage\n\nTheme.shared.strings.subject.updateSubjectLoadingTitle\nTheme.shared.strings.subject.updateSubjectLoadingMessage\n\nTheme.shared.strings.subject.deleteSubjectLoadingTitle\nTheme.shared.strings.subject.deleteSubjectLoadingMessage\n\nTheme.shared.strings.subject.addSubjectBoardingPassLoadingTitle\nTheme.shared.strings.subject.addSubjectBoardingPassLoadingMessage\n\nTheme.shared.strings.subject.deleteSubjectBoardingPassLoadingTitle\nTheme.shared.strings.subject.deleteSubjectBoardingPassLoadingMessage\n</code></pre></p>"},{"location":"Features/SubjectManagement/SubjectManagement_LoadingView.html#colors","title":"Colors","text":"AndroidiOS <p>You can change the text colors by overriding the following color resource (It affects all texts): <pre><code>&lt;color name=\"colorFaceCaptureTxtDarkSdkEnrolment\"&gt;#1A1C1E&lt;/color&gt;\n</code></pre></p> <p>You can change the background color by overriding the following color resource: <pre><code>&lt;color name=\"colorOverlayFeedbackBgSdkEnrolment\"&gt;#EAEEF6&lt;/color&gt;\n</code></pre></p> <p>You can change the text colors by overriding the following color in Theme class (It affects all Loading Screens): <pre><code>Theme.shared.colors.checkPermission.title\nTheme.shared.colors.checkPermission.subtitle\n</code></pre> You can change the background color by overriding the following color in Theme class(It affects all Loading Screens): <pre><code>Theme.shared.colors.checkPermission.background\n</code></pre></p>"},{"location":"Features/SubjectManagement/SubjectManagement_LoadingView.html#styles","title":"Styles","text":"AndroidiOS <p>You can extend the styles we use and override any properties (textColor, textSize, fontFamily, etc...) you want. <pre><code>&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Title.Centered\"&gt;\n&lt;style name=\"Theme.Sdk.Enrolment.TextView.Dark.Subtitle.Centered\"&gt;\n</code></pre> Note: It will affect every component that uses the same style.</p> <p>You can change the font through the theme class (this will affect all text in the app): <pre><code>Theme.shared.fonts.bold\nTheme.shared.fonts.regular\n</code></pre></p>"},{"location":"Features/SubjectManagement/SubjectManagement_LoadingView.html#image","title":"Image","text":"AndroidiOS <p>You can change the loading animation by adding a raw json animation file with the following name: <pre><code>loading_subject_sdk_enrolment.json\n</code></pre></p> <p>You can change the loading image by overriding the following image name in Theme class <pre><code>Theme.shared.animations.subject.loadingCreate\n</code></pre></p>"},{"location":"Features/SubjectManagement/SubjectManagement_LoadingView.html#use-your-own-layouts","title":"Use your own layouts","text":"AndroidiOS <p>To use your own loading screen for subject feature, you need to implement the MobileID SDK Interface for that view.</p> <p>In this case: ICustomSubject.LoadingView <pre><code>interface LoadingView {\n    fun onServerCommunication()\n    fun onAddingSubject()\n    fun onGettingSubject()\n    fun onUpdatingSubject()\n    fun onDeletingSubject()\n    fun onAddingBoardingPass()\n    fun onDeletingBoardingPass()\n    fun hideLoading()\n}\n</code></pre> You can use these functions to change loading screen texts, or you can opt to ignore those functions.</p> <p>For example create a class SubjectLoadingCustomView, create a layout file and bind it.</p> <pre><code>class SubjectLoadingCustomView (\n   context: Context\n) : LinearLayoutCompat(context), ICustomSubject.LoadingView {\nprivate var binding: ViewSubjectLoadingBinding\n\n   init {\n       binding = ViewSubjectLoadingBinding.inflate(LayoutInflater.from(context), this)\n       orientation = VERTICAL\n       gravity = Gravity.CENTER\n   }\n\n   override fun onServerCommunication() {\n       // Do nothing\n   }\n\n   override fun onAddingSubject() {\n       binding.tvSubjectLoadingTitle.text = \"Adding subject\"\n   }\n\n   override fun onGettingSubject() {\n       binding.tvSubjectLoadingTitle.text = \"Getting subject\"\n   }\n\n   override fun onUpdatingSubject() {\n       binding.tvSubjectLoadingTitle.text = \"Updating subject\"\n   }\n\n   override fun onDeletingSubject() {\n       binding.tvSubjectLoadingTitle.text = \"Deleting subject\"\n   }\n\n   override fun onAddingBoardingPass() {\n       binding.tvSubjectLoadingTitle.text = \"Adding boarding pass to subject\"\n   }\n\n   override fun onDeletingBoardingPass() {\n       binding.tvSubjectLoadingTitle.text = \"Removing subject's boarding pass\"\n   }\n\n   override fun hideLoading() {\n        // Do nothing\n   }\n}\n</code></pre> <p>You need to register a class of type SubjectLoadingViewType through the following function of EnrolmentViewRegister <pre><code>public func registerSubjectLoadingView(_ viewType: SubjectLoadingViewType)\n</code></pre></p> <p>The SubjectLoadingOverlayViewType class needs to respect the following protocols:</p> <pre><code>public protocol FeatureLoadingViewInterface {\n    func onPreFeatureLoading()\n    func onPostFeatureLoading()\n    func hideLoading()\n}\n\npublic typealias FeatureLoadingViewType = FeatureLoadingView.Type\npublic typealias FeatureLoadingView = UIView &amp; FeatureLoadingViewInterface\n\npublic typealias LoadingOverlayViewType = LoadingOverlayView.Type\npublic typealias LoadingOverlayView = UIView &amp; LoadingOverlayViewInterface\n\npublic protocol SubjectLoadingViewInterface: FeatureLoadingViewInterface {\n    func onAddingSubject()\n    func onGettingSubject()\n    func onUpdatingSubject()\n    func onDeletingSubjec()\n    func onAddingBoardingPass()\n    func onDeletingBoardingPass()\n}\n\npublic typealias SubjectLoadingViewType = SubjectLoadingView.Type\npublic typealias SubjectLoadingView = UIView &amp; SubjectLoadingViewInterface\n</code></pre> <p>Example: <pre><code>class LoadingView: SubjectLoadingView {\n// MARK: - Initialization\n\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        //add any UI customization you need\n    }\n\n// MARK: - Functions\n\n    func onPreFeatureLoading() {\n        //add any UI customization you need\n    }\n\n    func onPostFeatureLoading() {\n        //add any UI customization you need\n    }\n\n    func hideLoading() {\n        //You can stop animations or other activities that consumes resources \n    }\n\n    func onAddingSubject() {\n        //add any UI customization you need\n    }\n\n    func onGettingSubject() {\n        //add any UI customization you need\n    }\n\n    func onUpdatingSubject() {\n        //add any UI customization you need\n    }\n\n    func onDeletingSubjec() {\n        //add any UI customization you need\n    }\n\n    func onAddingBoardingPass() {\n        //add any UI customization you need\n    }\n\n    func onDeletingBoardingPass() {\n        //add any UI customization you need\n    }\n}\n</code></pre></p>"},{"location":"MigrationGuide/MigrationGuide_Android.html","title":"Migration Guide","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#from-720-to-800","title":"From 7.2.0 to 8.0.0","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#required-changes","title":"Required Changes","text":"<ul> <li>Developers are now required to specify the provider for the orz/mrz and rfid features. Check the updated Getting Started page</li> <li>The contract for each feature has changed, instead of making use of the Activity Launcher contract, a standard callback has been added. Check each feature page for more details.</li> <li>Enrolment is now a Singleton, instead of a builder you need to call Enrolment.initialize() passing the required parameters to make the Enrolment available anywhere. Check homepage for more details.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#from-711-to-720","title":"From 7.1.1 to 7.2.0","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#optional-changes","title":"Optional Changes","text":"<ul> <li>If you want to activate the Face Capture timeout, then you need to pass a value in milliseconds to faceCaptureTimeout in BiometricFaceCaptureParameters.</li> <li>If you mention the ScanTimeout Error type somewhere, you need to change it to Timeout due to the name change.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#from-710-to-711","title":"From 7.1.0 to 7.1.1","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#optional-changes_1","title":"Optional Changes","text":"<ul> <li>If you use some resources from VB ImageProcessor, you will have to replace it, as it's now private to the SDK.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#from-700-to-710","title":"From 7.0.0 to 7.1.0","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#required-changes_1","title":"Required Changes","text":"<ul> <li>As part of the security improving efforts a <code>candidateHash</code> and <code>referenceHash</code> have been added to the BiometricMatchParameters, these can be found in the generated reports.</li> <li>Similarly, the build subject operation needs the generated <code>ProcessReport</code> and <code>DocumentReaderReport</code> that include the above hashes to verify data integrity. If you already use these parameters on the BuildSubjectParameters you don't need to take any action.</li> <li>The package name now needs to be added to the backoffice. You may need to contact Vision-Box for this update.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#optional-changes_2","title":"Optional Changes","text":"<ul> <li>Add a public key on the initial configuration together with a private key setup on the backoffice to ensure encrypted requests.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#from-523-to-700","title":"From 5.2.3 to 7.0.0","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#required-changes_2","title":"Required Changes","text":"<ul> <li>Replace the signatures that do not use the ActivityLauncher contract;</li> <li>Remove the <code>get</code>, <code>update</code> and <code>delete</code> <code>Subject</code> operations. You should now save the <code>Subject</code> locally if you want to have a copy to check later. Updating a <code>Subject</code> is no longer supported as well so, you must create a new one if you want to for example, add a boarding pass;</li> <li>Handle errors by new field ErrorType instead of checking every possible errors;</li> <li>Filter through Biometrics by their source: Face, Chip or OCR;</li> <li>Rename enums to PascalCase, MALE is now Male, etc.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#from-521-to-522","title":"From 5.2.1 to 5.2.2","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#required-changes_3","title":"Required Changes","text":"<ul> <li>Contact Vision-Box to update apiKey used before testing new version. (Threshold values changed)</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#from-510-to-520","title":"From 5.1.0 to 5.2.0","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#required-changes_4","title":"Required Changes","text":"<ul> <li>Update camera2 library dependency to 1.2.3</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#optional-changes_3","title":"Optional Changes","text":"<ul> <li>If you are using a value of less than 10 seconds or higher than 60 seconds for either the scanner or rfid reader timeout in  ReadDocumentParameters you need to change the value;</li> <li>It's no longer possible to disable the scanner or rfid reader timeout in  ReadDocumentParameters.</li> <li>The default face capture frame is now oval, to keep using the rectangular change the BiometricFaceCaptureParameters frameFormat</li> <li>Refactor any preview custom view that you might be using to be an independent activity/fragment in your own flow.</li> <li>Refactor any error custom view that you might be using to be an independent activity/fragment in your own flow.</li> <li>Remove success custom views that you might be using as they no longer exist.</li> <li>Remove FaceCapture BiometricProcessView and FaceProcessView as they were merged into the loading view.</li> <li>Update remaining custom views with their new contracts.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#from-503-to-510","title":"From 5.0.3 to 5.1.0","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#required-changes_5","title":"Required Changes","text":"<ul> <li>Remove the parameter showLivenessIcon from BiometricFaceCaptureParameters</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#optional-changes_4","title":"Optional Changes","text":"<ul> <li>Add parameter includeTemplate in BiometricMatchParameters to receive a template.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#from-501-to-503","title":"From 5.0.1 to 5.0.3","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#optional-changes_5","title":"Optional Changes","text":"<ul> <li>Remove the context parameter from the \"startDatabaseUpdate\" method in the facade</li> <li>The error parameter in the RegulaDatabaseListener's unableToPrepareDatabase method is now optional\"</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#from-425-to-501","title":"From 4.2.5 to 5.0.1","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#gradle","title":"Gradle","text":"<ul> <li>Update minSdkVersion from 21 to 23;</li> <li>Update compileSdkVersion to 31;</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#sdk","title":"SDK","text":""},{"location":"MigrationGuide/MigrationGuide_Android.html#required-changes_6","title":"Required Changes","text":"<ul> <li>The DataResultExtra class and ResultCode class's are now internal and you can handle the feature's result using our ResultHandler created for each feature. This feature ResultHandler will return a model containing the result of the feature. Check the \"Handle Results\" section of each feature to understand how to handle results.</li> <li>Rename BiometricMatchParameters path to \"com.visionbox.mobileid.sdk.enrolment.data.biometricFaceMatch.BiometricMatchParameters\";</li> <li>Rename SubjectBuilderError path to \"com.visionbox.mobileid.sdk.enrolment.data.subject.subjectBuilder.error.SubjectBuilderError\";</li> <li>Rename BuildSubjectParameters path to \"com.visionbox.mobileid.sdk.enrolment.data.subject.subjectBuilder.BuildSubjectParameters\";</li> <li>Rename SubjectPermissionDenied to SubjectPermissionDeniedError and rename SubjectNotFound to SubjectNotFoundError;</li> <li>Removed Vision-Box parameters from the BiometricFaceCaptureParameters. These configurations are now on backoffice;</li> <li>Removed Vision-Box parameters from the BiometricMatchParameters. These configurations are now on backoffice;</li> <li>Removed Subject's validateBiometricQuality configuration. This configuration is now on backoffice;</li> <li>Removed BoardingPassScanConfig. The Boarding Pass configuration is now on backend level;</li> <li>All Serializable classes changed to Parcelable. Check your onActivityResult methods and change \"getSerializableExtra\" to \"getParcelableExtra\";</li> <li>Biometric Face Match and Subject features won't return a result, instead the results are obtained using the Android onActivityResult method. Check README for information on how to handle the results for these two features and also how you can use custom views for these features if you need it;</li> <li>The methods \"addBoardingPass\" and \"deleteBoardingPass\" of the Enrolment won't return direct response, the behavior should be the same of the other Subject Enrolment methods;</li> <li>Removed RX module;</li> <li>The \"buildSubject\" enrolment method has a new parameter: <pre><code>fun buildSubject(activity: Activity, params: BuildSubjectParameters)\n</code></pre></li> </ul>"},{"location":"MigrationGuide/MigrationGuide_Android.html#optional-changes_6","title":"Optional Changes","text":"<ul> <li>If you are using fragments, you can now change to the new Enrolment methods that support Fragments; <pre><code>// Example:\nfun readDocument(context: Context, params: DocumentReaderParameters, resultLauncher: ActivityResultLauncher&lt;Intent&gt;)\n</code></pre></li> <li>Removed localization support from backend, if you used our screens and our localization definition from backoffice, you must now create your own files.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html","title":"Migration Guide","text":""},{"location":"MigrationGuide/MigrationGuide_iOS.html#from-720-to-800","title":"From 7.2.0 to 8.0.0","text":""},{"location":"MigrationGuide/MigrationGuide_iOS.html#required-changes","title":"Required Changes","text":"<ul> <li>Developers are now required to specify the provider for the orz/mrz and rfid features. Check the updated Getting Started page</li> <li>Enrolment is now a Singleton, instead of a builder you need to call Enrolment.shared, passing the required parameters to make the Enrolment available anywhere. Check homepage for more details.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#from-712-to-720","title":"From 7.1.2 to 7.2.0","text":""},{"location":"MigrationGuide/MigrationGuide_iOS.html#optional-changes","title":"Optional Changes","text":"<ul> <li>faceCaptureTimeout have been added to the BiometricFaceCaptureParameters, to be able to start the RFID scan automatically</li> <li>If you mention the ScanTimeout Error type somewhere, you need to change it to Timeout due to the name change.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#from-710-to-711","title":"From 7.1.0 to 7.1.1","text":""},{"location":"MigrationGuide/MigrationGuide_iOS.html#optional-changes_1","title":"Optional Changes","text":"<ul> <li>showRFIDInstructions have been added to the ReadDocumentParameters, to be able to start the RFID scan automatically</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#from-700-to-710","title":"From 7.0.0 to 7.1.0","text":""},{"location":"MigrationGuide/MigrationGuide_iOS.html#required-changes_1","title":"Required Changes","text":"<ul> <li>As part of the security improving efforts a <code>candidateHash</code> and <code>referenceHash</code> have been added to the BiometricMatchParameters, these can be found in the generated reports.</li> <li>Similarly, the build subject operation needs the generated <code>ProcessReport</code> and <code>DocumentReaderReport</code> that include the above hashes to verify data integrity. If you already use these parameters on the BuildSubjectParameters you don't need to take any action.</li> <li>The package name now needs to be added to the backoffice. You may need to contact Vision-Box for this update.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#optional-changes_2","title":"Optional Changes","text":"<ul> <li>Add a public key on the initial configuration together with a private key setup on the backoffice to ensure encrypted requests.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#from-523-to-700","title":"From 5.2.3 to 7.0.0","text":""},{"location":"MigrationGuide/MigrationGuide_iOS.html#required-changes_2","title":"Required Changes","text":"<ul> <li>Remove the <code>get</code>, <code>update</code> and <code>delete</code> <code>Subject</code> operations. You should now save the <code>Subject</code> locally if you want to have a copy to check later. Updating a <code>Subject</code> is no longer supported as well so, you must create a new one if you want to for example, add a boarding pass;</li> <li>Handle errors by new field ErrorType instead of checking every possible errors;</li> <li>Filter through Biometrics by their source: Face, Chip or OCR;</li> <li>Rename enums to PascalCase, MALE is now Male, etc.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#from-510-to-520","title":"From 5.1.0 to 5.2.0","text":""},{"location":"MigrationGuide/MigrationGuide_iOS.html#required-changes_3","title":"Required Changes","text":"<ul> <li>If you are using a value of less than 10 seconds or greater than 60 for the scannerTimeout or rfidTimeout in  ReadDocumentParameters you need to change the value.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#optional-changes_3","title":"Optional Changes","text":"<ul> <li>If you want to continue with the square frame you need to set the frameShape field of the class BiometricFaceCaptureParameters to .square</li> <li>Refactor any preview custom view that you might be using to be an independent UIViewController in your own flow.</li> <li>Refactor any error custom view that you might be using to be an independent UIViewController in your own flow.</li> <li>Update remaining custom views with their new protocols.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#from-500-to-510","title":"From 5.0.0 to 5.1.0","text":""},{"location":"MigrationGuide/MigrationGuide_iOS.html#required-changes_4","title":"Required Changes","text":"<ul> <li>Removed liveness status parameter from the BiometricFaceCaptureParameters.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#optional-changes_4","title":"Optional Changes","text":"<ul> <li>If you are using BiometricFaceCapturePreviewView custom view, you must remove the property livenessStatus.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#optional-changes_5","title":"Optional Changes","text":"<ul> <li>Add parameter includeTemplate in BiometricMatchParameters to receive a template.</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#from-424-to-500","title":"From 4.2.4 to 5.0.0","text":""},{"location":"MigrationGuide/MigrationGuide_iOS.html#cocoapods","title":"CocoaPods","text":"<ul> <li>Run pod update &amp; install</li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#required-changes_5","title":"Required Changes","text":"<ul> <li>Removed BoardingPassScanConfig. The Boarding Pass configuration is now on backend side;</li> <li>Removed Vision-Box parameters from the BiometricFaceCaptureParameters. These configurations are now on backoffice;</li> <li>Removed Vision-Box parameters from the BiometricMatchParameters. These configurations are now on backoffice;</li> <li>Removed Subject's validateBiometricQuality configuration. This configuration is now on backoffice;</li> <li>Removed Alamofire lib;</li> <li>Removed specific feature loadings and created a generic one, e.g. remove calls for BoardingPassScannerLoadingView &amp; BoardingPassScannerLoadingView and replace it with the new one LoadingOverlayViewType.</li> <li></li> </ul>"},{"location":"MigrationGuide/MigrationGuide_iOS.html#optional-changes_6","title":"Optional Changes","text":"<ul> <li>Added new method startUpdateDatabase to allow database download. If the method isn't called, then it will be downloaded upon the first usage of our sdk.</li> <li>Removed localization support from backend, if you used our screens and our localization definition from backoffice, you must now create your own files.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html","title":"MobileID SDK - Release Notes","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#811","title":"8.1.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#whats-new","title":"What's new","text":"<ul> <li>Added BOM configuration to ensure version compatibility over document reader providers and the SDK.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements","title":"Improvements","text":"<ul> <li>Fixed the overlapping of face capture frame with the text in portrait tablets.</li> <li>Fixed issues with boarding pass parser during the validation phase.</li> <li>Updated IdDocument's properties issuingState and nationality to use the country ISO Code instead of its name.</li> <li>Released Regula Provider 1.0.4 with Regula SDK version 7.7.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#810","title":"8.1.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#whats-new_1","title":"What's new","text":"<ul> <li>Added a new property to matchReport that indicates the score of the biometric match in success cases as well.</li> <li>Added rotation configuration to SDK screens.</li> <li>New IdDocument class that will replace DocumentData in the document reader report.</li> <li>Added offline mode support.</li> <li>New license mechanism via jwt token.</li> <li>Allow to save biometric face capture in different formats such as JPEG or PNG.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_1","title":"Improvements","text":"<ul> <li>Fixed issue in face capture where the face was being cropped too much or not appearing at all.</li> <li>Improved internal logging capabilities.</li> <li>Fixed crash in document reader when cancelling during the initialization process.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#warning","title":"Warning","text":"<ul> <li>The object DocumentData from the Document Reader feature is deprecated and will be removed in the future, please update to the new object IdDocument.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#801","title":"8.0.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#whats-new_2","title":"What's new","text":"<ul> <li>Added deinitialize method to Enrolment to allow for re-initialization with different parameters as needed.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_2","title":"Improvements","text":"<ul> <li>Fixed crash when wrong timeout parameters are used.</li> <li>Small Bug fixes.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#800","title":"8.0.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#whats-new_3","title":"What's new","text":"<ul> <li>New, streamlined Face Capture UI.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_3","title":"Improvements","text":"<ul> <li>Improved Enrolment methods to accept a callback class instead of a result launcher.</li> <li>Reduced initialization time for document reader.</li> <li>Rotated photo when using the back camera.</li> <li>Removed unnecessary screens for a cleaner user experience. Check sample in github for examples with the error and preview screens.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#technical-enhancements","title":"Technical Enhancements","text":"<ul> <li>Centralized configuration management.</li> <li>Image capture size optimizations.</li> <li>Modularized the SDK for better maintainability and scalability.</li> <li>Bugs fixes.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#removed","title":"Removed","text":"<ul> <li>Sentry;</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#warning_1","title":"Warning","text":"<ul> <li>The square option from FaceCaptureFrameFormat is deprecated and will be removed in the future, please use the oval option.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#732","title":"7.3.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_4","title":"Improvements","text":"<ul> <li>Updated Regula SDK to version 7.5.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#731","title":"7.3.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#changes","title":"Changes","text":"<ul> <li>Small changes to the face capture animation</li> <li>Providing an invalid api key will result in an error when calling any of the SDK's features</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#730","title":"7.3.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_5","title":"Improvements","text":"<ul> <li>Add choice of the scenarios for the document capture</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#722","title":"7.2.2","text":"<ul> <li>Remove Sentry has an external dependency</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#721","title":"7.2.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_6","title":"Improvements","text":"<ul> <li>Updated Regula SDK to version 7.4.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#720","title":"7.2.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_7","title":"Improvements","text":"<ul> <li>Face Capture Timeout: Introduced a configurable timeout for the Face Capture feature. This can be set using the faceCaptureTimeout parameter in BiometricFaceCaptureParameters. The timeout default is disabled and the minimum allowed timeout is 30 seconds.</li> <li>Improved localization support documentation</li> <li>Error Handling: Removed the retry button from the default error screen for InternalError cases as retries are not effective in these situations.</li> <li>Updated Regula SDK to version 7.3.</li> <li>Changed the ScanTimeout error type to Timeout.</li> <li>Fixed an infinite loop issue in the Document Reader.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#713","title":"7.1.3","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_8","title":"Improvements","text":"<ul> <li>Fix an issue with passive authentication while using Regula version 7.2</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#712","title":"7.1.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_9","title":"Improvements","text":"<ul> <li>Update Regula to 7.2</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#711","title":"7.1.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_10","title":"Improvements","text":"<ul> <li>Handle SubjectDataIntegrityFailed to prevent crashes while building the subject if the data validation fails.</li> <li>Change VB ImageProcessor's visibility to private.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#710","title":"7.1.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_11","title":"Improvements","text":"<ul> <li>Improved security measures:<ul> <li>Communications with the backend are now encrypted using hybrid encryption;</li> <li>Data integrity is verified in communications with the backend;</li> <li>Data integrity is verified in the build subject and face match operations;</li> <li>HTTP responses are signed and verifiable</li> </ul> </li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#whats-new_4","title":"What's new","text":"<ul> <li>Form feature</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#702","title":"7.0.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_12","title":"Improvements","text":"<ul> <li>Fixed an issue with some boarding pass formats</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#701","title":"7.0.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_13","title":"Improvements","text":"<ul> <li>Removed mandatory preview screen in face capture;</li> <li>Fixed an issue with regula database listener;</li> <li>Changed adding a subject without a boarding pass when it's mandatory error code to it's own error code;</li> <li>Clean Regula resources upon document reader finished in order to reduce memory consumption;</li> <li>Added a new parameter to DocumentReaderConfig called checkHologram* to enable Regula's hologram scan, to prevent fraudulent documents.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#700","title":"7.0.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#important","title":"IMPORTANT","text":"<ul> <li>In Q1 2024, 7.1.0 will be released targeting API 34.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#whats-new_5","title":"What's new","text":"<ul> <li>New subject service (now works asynchronously)</li> <li>Removed the <code>get</code>, <code>delete</code> and <code>update</code> subject signatures;</li> <li>Clients need to save the subject locally after adding.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_14","title":"Improvements","text":"<ul> <li>Removed the signatures that use the deprecated <code>onActivityResult</code> function that were deprecated;</li> <li>Removed some external dependencies to improve SDK size;</li> <li>Changed Java compile version to 17;</li> <li>Replaced synthetic views with view binding.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#removed_1","title":"Removed","text":"<ul> <li>Moshi;</li> <li>Restring</li> <li>kotlin-android-extensions plugin.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#523","title":"5.2.3","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_15","title":"Improvements","text":"<ul> <li>Improved frame of face capture drawing by adjusting the ratios.</li> <li>Fix issues that subjects couldn't be created with national ID documents and resident cards.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#522","title":"5.2.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_16","title":"Improvements","text":"<ul> <li>Improved Face capture process by:</li> <li>Fix issue with new mouth open algorithm (requires changes in Backoffice before upgrading)</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#521","title":"5.2.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_17","title":"Improvements","text":"<ul> <li>Improved Face capture process by:</li> <li>Calculate input frame lightning conditions, contrast and sharpness.</li> <li>Improved multiple faces check to focus on the closer face.</li> <li>Changed mouth open algorithm.</li> <li>Fixed switch between frontal and back cameras.</li> <li>Added CameraConfig to BiometricFaceCaptureParameters to control if the toggle camera button should appear and the initial camera facing (Front or back camera)</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#520","title":"5.2.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_18","title":"Improvements","text":"<ul> <li>Added a minimum value of 10 seconds, and a maximum value of 60 seconds for document scanner and rfid reader timeouts.</li> <li>Added feature to disable regula passive auth for some documents by their ID.</li> <li>Removed preview custom views from every feature, if you don't want our default screen, turn off the showPreview flag in feature parameters.</li> <li>Removed error custom views from every feature, if you don't want our default screen, turn off the showErrors flag in feature parameters.</li> <li>Removed success custom view interfaces as they were no longer being used by our SDK.</li> <li>Improved loading animations.</li> <li>Improved image handling process.</li> <li>Changed the default face capture frame to Oval shape, but added an option in parameters to use the square option as well.</li> <li>Refactor remaining custom views interfaces to make it easier to implement.</li> <li>Separated Face Capture Image processing to another SDK in order to increase testability.</li> <li>Updated Regula version to 6.8.</li> <li>Fix timezone bug on preview screen.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#warning_2","title":"Warning","text":"<ul> <li>Functions marked with deprecated will be removed in version 6.0.0, please update following their suggestions.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#513","title":"5.1.3","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_19","title":"Improvements","text":"<ul> <li>Updated to Regula 6.6;</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#512","title":"5.1.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_20","title":"Improvements","text":"<ul> <li>Fixed bug that Android devices which API level was 9 or less couldn't detect when the user had it's mouth open during real time analysis;</li> <li>Calculate intra ocular distance in order to detect proximity to the camera;</li> <li>Fixed bug that sometimes final image wouldn't be processed and caused an infinite loading during face capture;</li> <li>Fixed bug that RFID custom views were being overlapped.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#downgrades","title":"Downgrades","text":"<ul> <li>Downgraded regula to 6.3.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#511","title":"5.1.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_21","title":"Improvements","text":"<ul> <li>Updated to Regula 6.6;</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#510","title":"5.1.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_22","title":"Improvements","text":"<ul> <li>Minor UI/UX improvements.</li> <li>Remove Liveness icon from Face Capture preview</li> <li>Added TemplateOption to BiometricMatchParameters</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#downgrades_1","title":"Downgrades","text":"<ul> <li>Downgraded regula to 6.3.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#503","title":"5.0.3","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#whats-new_6","title":"What's new","text":"<ul> <li>Added a new method to the enrolment facade to remove the database update listener</li> <li>New liveness endpoint.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_23","title":"Improvements","text":"<ul> <li>Improved document reader timeouts functionality, so that it's possible to disable them.</li> <li>Improved RFID timeout, now only starts after instruction screen.</li> <li>Improved BuildSubjectParameters, If no custom language is provided, use the language defined in the EnrolmentConfig or as last resort the device language.</li> <li>Added animations to improve UX.</li> <li>Added progress bar to show that the chip is being read.</li> <li>Fixed the verification message that checked if the user has it's mouth open while taking the selfie.</li> <li>Improved real time analysis of selfie capture to improve feedback on older smartphones.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#502","title":"5.0.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_24","title":"Improvements","text":"<ul> <li>Updated to Regula 6.6;</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#501","title":"5.0.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_Android.html#whats-new_7","title":"What's new","text":"<ul> <li>Added Fragment support to Enrolment methods;</li> <li>Added logs to Subject Builder;</li> <li>Biometric Face Match has a new workflow. It uses the onActivityResult Android architecture to return results;</li> <li>Subject Enrolment methods have a new workflow. They use the onActivityResult Android architecture to return results;</li> <li>Biometric Face Capture now has real-time image processing with feedback to increase odds of taking a quality picture for the match service;</li> <li>The EnrolmentConfig has a new configuration to set the SDK language;</li> <li>Document Reader database download can now be controlled by the client;</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#improvements_25","title":"Improvements","text":"<ul> <li>Minimum SDK version changed to 23;</li> <li>Upgraded external dependencies;</li> <li>Updated to Regula 6.3;</li> <li>Migrated from Firebase to MLKit;</li> <li>Improved Sentry logs;</li> <li>Improved feature logs;</li> <li>Improved SDK default UI;</li> <li>Simplified SDK configurations by moving some to backoffice;</li> <li>New Biometric Match service that improved performance;</li> <li>Uses Mobile API 4.0;</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_Android.html#removed_2","title":"Removed","text":"<ul> <li>OkHttpClient library;</li> <li>RX support;</li> <li>Localization support from backend;</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html","title":"MobileID SDK - Release Notes","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#813","title":"8.1.3","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements","title":"Improvements","text":"<ul> <li>Improved animation time in the Biometric Face Capture Feature</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#812","title":"8.1.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_1","title":"Improvements","text":"<ul> <li>Removed dependency on external JWTDecoder library</li> <li>Enhanced UI layout consistency - by improving ui margins</li> <li>Fixed issue on square biometric face capture callback being triggered multiple times</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#810","title":"8.1.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#whats-new","title":"What's new","text":"<ul> <li>Added a new property to matchReport that indicates the score of the biometric match in success cases as well.</li> <li>New IdDocument class that will replace DocumentData in the document reader report.</li> <li>Added offline mode support.</li> <li>New license mechanism via jwt token.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_2","title":"Improvements","text":"<ul> <li>Improved custom loading screen in subject feature</li> <li>Improved internal logging capabilities.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#warning","title":"Warning","text":"<ul> <li>The object DocumentData from the Document Reader feature is deprecated and will be removed in the future, please update to the new object IdDocument.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#800","title":"8.0.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#whats-new_1","title":"What's new","text":"<ul> <li>New, streamlined Face Capture UI.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_3","title":"Improvements","text":"<ul> <li>Reduced initialization time for document reader.</li> <li>Mirror photo when using the front camera.</li> <li>Removed unnecessary screens for a cleaner user experience. Check sample in github for examples with the error and preview screens.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#technical-enhancements","title":"Technical Enhancements","text":"<ul> <li>Centralized configuration management.</li> <li>Modularized the SDK for better maintainability and scalability.</li> <li>Bugs fixes.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#warning_1","title":"Warning","text":"<ul> <li>The square option from BiometricFaceCaptureFrameOptions is deprecated and will be removed in the future, please use the oval option.  </li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#734","title":"7.3.4","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_4","title":"Improvements","text":"<ul> <li>BiometricFaceCapture:  reduced the time required to open the camera, improving user experience.</li> <li>Timezone Handling: Corrected a problem with how the application handles timezone data.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#733","title":"7.3.3","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_5","title":"Improvements","text":"<ul> <li>Updated Regula SDK to version 7.5.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#732","title":"7.3.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_6","title":"Improvements","text":"<ul> <li>Fix issues with Camera permissions.</li> <li>Updated Lottie SDK to version 4.4.1.</li> <li>Fix face capture animation bug, where the face selection frame was moved to top left corner.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#731","title":"7.3.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_7","title":"Improvements","text":"<ul> <li>Updated VBDependencyInjector SDK to version 1.0.5.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#730","title":"7.3.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_8","title":"Improvements","text":"<ul> <li>Add choice of the scenarios for the document capture</li> <li>Remove Sentry has an external dependency</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#722","title":"7.2.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_9","title":"Improvements","text":"<ul> <li>Updated Sentry SDK to version 8.33.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#721","title":"7.2.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_10","title":"Improvements","text":"<ul> <li>Updated Regula SDK to version 7.4.</li> <li>Support to SPM </li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#720","title":"7.2.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_11","title":"Improvements","text":"<ul> <li>Face Capture Timeout: Introduced a configurable timeout for the Face Capture feature. This can be set using the faceCaptureTimeout parameter in BiometricFaceCaptureParameters. The timeout default is disabled and the minimum allowed timeout is 30 seconds. </li> <li>Improved localization support documentation</li> <li>Error Handling: Removed the retry button from the default error screen for InternalError cases as retries are not effective in these situations.</li> <li>Updated Regula SDK to version 7.3.</li> <li>Changed the ScanTimeout error type to Timeout.</li> <li>Fixed an infinite loop issue in the Document Reader.</li> <li>Resolved layout inconsistencies in the Face Capture UI.</li> <li>Prevented simultaneous pressing of RFID skip and start buttons in the Document Reader.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#712","title":"7.1.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_12","title":"Improvements","text":"<ul> <li>Update Regula to 7.2</li> <li>Improvements in BiometricFaceCapture feature.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#711","title":"7.1.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_13","title":"Improvements","text":"<ul> <li>Added a new parameter to ReadDocumentParameters called showRFIDInstructions  that allows you to skip the RFID scan instruction screen</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#710","title":"7.1.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_14","title":"Improvements","text":"<ul> <li>Improved security measures:<ul> <li>Communications with the backend are now encrypted using hybrid encryption;</li> <li>Data integrity is verified in communications with the backend;</li> <li>Data integrity is verified in the build subject and face match operations;</li> <li>HTTP responses are signed and verifiable</li> </ul> </li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#whats-new_2","title":"What's new","text":"<ul> <li>Form feature</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#701","title":"7.0.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_15","title":"Improvements","text":"<ul> <li>Fixed an issue with Boarding Pass Preview clickable rows </li> <li>Added a new parameter to DocumentReaderConfig called checkHologram* to enable Regula's hologram scan, to prevent fraudulent documents.</li> <li>Removed mandatory preview screen in face capture;</li> <li>Changed adding a subject without a boarding pass when it's mandatory error code to it's own error code;</li> <li>Fix id 215 and 224 to appear as IDCard in Document Reader </li> <li>Fix issues with oval drawing in Face Capture</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#700","title":"7.0.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#whats-new_3","title":"What's new","text":"<ul> <li>New subject service (now works asynchronously)</li> <li>Removed the <code>get</code>, <code>delete</code> and <code>update</code> subject signatures;</li> <li>Clients need to save the subject locally after adding.</li> <li>Improve error handling</li> <li>The boarding pass can be read from an image</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_16","title":"Improvements","text":"<ul> <li>Fix issues with Loading Screen Animations</li> <li>Add Camera permissions messages in Boarding Pass Scanner and Face Capture </li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#523","title":"5.2.3","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_17","title":"Improvements","text":"<ul> <li>Updated to Lottie 4.3.3</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#522","title":"5.2.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_18","title":"Improvements","text":"<ul> <li>Improved the fetching of needed resources in the DocumentReader feature.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#521","title":"5.2.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_19","title":"Improvements","text":"<ul> <li>Improved Face capture process by:</li> <li>Improved multiple faces check to focus on the closer face.</li> <li>Added CameraConfig to BiometricFaceCaptureParameters to control if the toggle camera button should appear and the initial camera facing (Front or back camera)</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#520","title":"5.2.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_20","title":"Improvements","text":"<ul> <li>The frameShape field of the class BiometricFaceCaptureParameters can now be set to choose between an oval or square shape, default is oval</li> <li>The scannerTimeout and rfidTimeout field of the class ReadDocumentParameters has a maximum and minimum value (maximum 60, minimum 10)</li> <li>The scannerTimeout field of the class ReadDocumentParameters can now be set to nil to be disabled</li> <li>Removed preview custom views from every feature, if you don't want our default screen, turn off the showPreview flag in feature parameters.</li> <li>Removed error custom views from every feature, if you don't want our default screen, turn off the showErrors flag in feature parameters.</li> <li>Refactor remaining custom views protocols to make it easier to implement.</li> <li>Added feature to disable regula passive auth for some documents by their ID.</li> <li>Improved loading animations.</li> <li>Improved image handling process.</li> <li>Updated Regula version to 6.8</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#511","title":"5.1.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_21","title":"Improvements","text":"<ul> <li>Updated to Lottie 3.4;</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#510","title":"5.1.0","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_22","title":"Improvements","text":"<ul> <li>Minor UI/UX improvements.</li> <li>Added TemplateOption to BiometricMatchParameters</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#removed","title":"Removed","text":"<ul> <li>Liveness icon from Face Capture preview screen</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#503","title":"5.0.3","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_23","title":"Improvements","text":"<ul> <li>Improved RFID timeout, now only starts after instruction screen.</li> <li>Improved error and timeout messages.\u00a0</li> <li>Improved UI</li> <li>Added animations to improve UX.</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#502","title":"5.0.2","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_24","title":"Improvements","text":"<ul> <li>Updated to Regula 6.6;</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#501","title":"5.0.1","text":""},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#whats-new_4","title":"What's new","text":"<ul> <li>Biometric Face Capture now has real-time image processing with more feedback to increase odds of taking a quality picture for the match service;</li> <li>The EnrolmentConfig has a new configuration to set the SDK language;</li> <li>Document Reader database download can now be controlled by the client;</li> <li>Added logs to Subject Builder;</li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#improvements_25","title":"Improvements","text":"<ul> <li>Upgraded external dependencies;</li> <li>Migrated to Vision framework for image processing;</li> <li>Improved Sentry logs;</li> <li>Improved feature logs;</li> <li>Improved SDK default UI;</li> <li>Simplified SDK configurations by moving some to backoffice;</li> <li>New Biometric Match service that improved performance;</li> <li>Uses Mobile API 4.0;</li> <li>Updated to Regula 6.3; </li> </ul>"},{"location":"ReleaseNotes/ReleaseNotes_iOS.html#removed_1","title":"Removed","text":"<ul> <li>Alamofire library;</li> <li>Localization support from backend;</li> </ul>"}]}